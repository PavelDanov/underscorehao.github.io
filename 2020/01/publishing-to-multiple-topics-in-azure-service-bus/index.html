<!doctype html><html lang><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Multiple topics There are two main approaches when it comes to topics in Azure Service Bus. Depending what&rsquo;s your architecture and needs you can have either:
 Filtered topic - this means you have only one topic for all of your event types. All publishers push messages onto that single topic. Some of the message fields and properties are then used for filtering by the subscribers since in most cases a subscriber will be interested only in certain types of messages.">
<title>
Publishing to Multiple Topics in Azure Service Bus
</title>
<link rel="shortcut icon" type=image/x-icon href=/>
<link rel=stylesheet href=/css/main.5c10ece54f1723f67c16bf8ad2a1e23710f204f7aafcd1bf844da01793141f4eea6da112cc59dba9d372cd954db7a2ec1bb612693ba493c3382236f993fe55d4.css integrity="sha512-XBDs5U8XI/Z8Fr+K0qHiNxDyBPeq/NG/hE2gF5MUH07qbaESzFnbqdNyzZVNt6LsG7YSaTukk8M4Ijb5k/5V1A==">
</head>
<body a=light>
<main class=page-content aria-label=Content>
<div class=w>
<a href=/>..</a>
<article>
<p class=post-meta>
<time datetime="2020-01-11 19:33:48 +0000 UTC">
2020-01-11
</time>
</p>
<h1>Publishing to Multiple Topics in Azure Service Bus</h1>
<aside>
<nav id=TableOfContents>
<ul>
<li><a href=#multiple-topics>Multiple topics</a></li>
<li><a href=#basic-setup>Basic Setup</a></li>
<li><a href=#the-na誰ve-approach>The na誰ve approach</a></li>
<li><a href=#introducing-the-itopicclient-resolver>Introducing the ITopicClient resolver</a></li>
</ul>
</nav>
</aside>
<h2 id=multiple-topics>Multiple topics</h2>
<p>There are two main approaches when it comes to topics in Azure Service Bus. Depending what&rsquo;s your architecture and needs you can have either:</p>
<ul>
<li><strong>Filtered topic</strong> - this means you have only one topic for all of your event types. All publishers push messages onto that single topic. Some of the message fields and properties are then used for filtering by the subscribers since in most cases a subscriber will be interested only in certain types of messages.</li>
<li><strong>Multiple topics</strong> - you have multiple topics for different domain events or channels of your system. You can still leverage the filtering to have more granular control in your subscribers. You can also have topics based on priority, event types etc.</li>
</ul>
<p>Our main concern in this post is the second use case and how to build a nice <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.topicclient?view=azure-dotnet"><strong><code>ITopicClient</code></strong></a> factory inside a .NET Core project. I&rsquo;ve built my example with Azure Functions, but 99.9% of the code is completely identical to what you would do in a normal .NET Core web service.</p>
<h2 id=basic-setup>Basic Setup</h2>
<p>If you haven&rsquo;t used <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.topicclient?view=azure-dotnet"><strong><code>ITopicClient</code></strong></a> and Azure Service Bus I recommend you read the following two articles before continuing:</p>
<ul>
<li><a href=https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-quickstart-topics-subscriptions-portal>Create Azure Service Bus topics and subscriptions</a></li>
<li><a href=https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions>Getting started with Service Bus topics</a></li>
</ul>
<p>Now that we know what libraries we&rsquo;ll be using we can start building our solution. The first step is to create our TopicClient which is easy enough</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:violet>var</span> topicClient = <span style=color:red>new</span> TopicClient(<span style=color:#87ceeb>&#34;AzureServiceBusConnectionString&#34;</span>, <span style=color:#87ceeb>&#34;TopicName&#34;</span>);
</code></pre></div><p>The two things we need are the ASB connection string and the topic to which we would like to publish messages.</p>
<p>Let&rsquo;s get the boilerplate code that is going to be used onward out of the way first. You&rsquo;ll need to have something like that in your <code>appsettings.json</code> file</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    &#34;ServiceBus&#34;: {
        &#34;Endpoint&#34;: <span style=color:#87ceeb>&#34;AsbFooBarEndpoint&#34;</span>,
        &#34;FooTopic&#34;: <span style=color:#87ceeb>&#34;foo&#34;</span>,
        &#34;BarTopic&#34;: <span style=color:#87ceeb>&#34;bar&#34;</span>
    }
}
</code></pre></div><p>And a simple POCO that you can map it to</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:red>public</span> <span style=color:red>class</span> ServiceBusOptions
{
    <span style=color:red>public</span> <span style=color:violet>string</span> Endpoint { <span style=color:red>get</span>; <span style=color:red>set</span>; }

    <span style=color:red>public</span> <span style=color:violet>string</span> FooTopic { <span style=color:red>get</span>; <span style=color:red>set</span>; }

    <span style=color:red>public</span> <span style=color:violet>string</span> BarTopic { <span style=color:red>get</span>; <span style=color:red>set</span>; }
}
</code></pre></div><p>Then you register your options in the startup</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:red>private</span> <span style=color:red>void</span> BindConfigurationOptions(IServiceCollection services)
{
    services.Configure&lt;ServiceBusOptions&gt;(options =&gt;
        Configuration.GetSection(<span style=color:#87ceeb>&#34;ServiceBus&#34;</span>)
            .Bind(options));
}
</code></pre></div><h2 id=the-na誰ve-approach>The na誰ve approach</h2>
<p>If we were doing the first example (filtered topic) we are pretty much done. You can register your <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.topicclient?view=azure-dotnet"><strong><code>ITopicClient</code></strong></a> as a <a href=https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-performance-improvements#reusing-factories-and-clients><strong>singleton</strong></a> and inject it in your DI container.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#0f0>// This is the Azure Functions host builder
</span><span style=color:#0f0>// In a web service you&#39;ll have the IServiceCollection
</span><span style=color:#0f0></span><span style=color:red>public</span> <span style=color:red>static</span> <span style=color:red>void</span> Configure(IFunctionsHostBuilder builder)
{
    builder.Services.AddSingleton&lt;ITopicClient&gt;(x =&gt;
    {
        <span style=color:violet>var</span> options = x.GetRequiredService&lt;IOptions&lt;ServiceBusOptions&gt;&gt;();
        <span style=color:red>return</span> <span style=color:red>new</span> <span style=color:red>new</span> TopicClient(options.Value.Endpoint, options.Value.FooTopic);
    });
}
</code></pre></div><p>Finally you just use the injected client to send messages to the <code>Foo</code> topic</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#0f0>// Code below uses a MediatR handler as an example
</span><span style=color:#0f0></span><span style=color:red>public</span> <span style=color:red>class</span> FooHandler : IRequestHandler&lt;Foo, <span style=color:violet>bool</span>&gt;
{
    <span style=color:red>private</span> <span style=color:red>readonly</span> ITopicClient topicClient;

    <span style=color:red>public</span> FooHandler(ITopicClient topicClient)
    {
        <span style=color:red>this</span>.topicClient = topicClient ?? <span style=color:red>throw</span> <span style=color:red>new</span> ArgumentNullException(nameof(topicClient));
    }

    <span style=color:red>public</span> <span style=color:red>async</span> Task&lt;<span style=color:violet>bool</span>&gt; Handle(Foo request, CancellationToken cancellationToken)
    {
        <span style=color:red>if</span> (request == <span style=color:red>null</span>) <span style=color:red>throw</span> <span style=color:red>new</span> ArgumentNullException(nameof(request));

        <span style=color:red>try</span>
        {
            <span style=color:red>await</span> topicClient.SendAsync(request.Message);
            <span style=color:red>return</span> <span style=color:red>true</span>;
        }
        <span style=color:red>catch</span> (Exception ex)
        {
            <span style=color:red>return</span> <span style=color:red>false</span>;
        }
    }
}
</code></pre></div><p>And that&rsquo;s that. We&rsquo;re done.</p>
<p>What happens however if we have to accommodate multiple topics? Do we inject multiple topics in the service/handler? Depending on your DI container are you even able to put multiple implementations of the same interface? Do we use a bunch of if statements and introduce cyclomatic complexity for deciding which topic client we want? These are all viable questions and solutions, but one elegant answer is hidden in the next section.</p>
<h2 id=introducing-the-itopicclient-resolver>Introducing the ITopicClient resolver</h2>
<p>In order to solve the problem at hand I want to minimize the complexity of dealing with multiple topics. I want the usage to be as simple as when using only one just like in the previous example. So how do we do that?</p>
<p>The first part of the problem is how to differentiate between the topic clients for each topic. We can do that by creating small wrapper classes around each client we have.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:red>public</span> <span style=color:red>class</span> FooClient
{
    <span style=color:red>public</span> <span style=color:red>readonly</span> ITopicClient TopicClient;

    <span style=color:red>public</span> FooClient(IOptions&lt;ServiceBusOptions&gt; options)
    {
        TopicClient = <span style=color:red>new</span> TopicClient(options.Value.Endpoint, options.Value.FooTopic);
    }
}

<span style=color:red>public</span> <span style=color:red>class</span> BarClient
{
    <span style=color:red>public</span> <span style=color:red>readonly</span> ITopicClient TopicClient;

    <span style=color:red>public</span> BarClient(IOptions&lt;ServiceBusOptions&gt; options)
    {
        TopicClient = <span style=color:red>new</span> TopicClient(options.Value.Endpoint, options.Value.BarTopic);
    }
}
</code></pre></div><p>Now that we have our clients we are going to create a factory with the help of a <code>delegate</code>. Based on a <code>key</code> we&rsquo;ll return the exact topic client we want when we want it!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:red>using</span> Microsoft.Azure.ServiceBus;

<span style=color:red>namespace</span> FooBarApp.Clients
{
    <span style=color:#0f0>// The key can be a string, Type, enum, int - whatever you need really
</span><span style=color:#0f0></span>    <span style=color:red>public</span> <span style=color:red>delegate</span> ITopicClient TopicResolver(<span style=color:violet>string</span> key);
}
</code></pre></div><p>The step where the magic happens is in our DI registration.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#0f0>// This is the Azure Functions host builder
</span><span style=color:#0f0>// In a web service you&#39;ll have the IServiceCollection
</span><span style=color:#0f0></span><span style=color:red>public</span> <span style=color:red>static</span> <span style=color:red>void</span> Configure(IFunctionsHostBuilder builder)
{
    builder.Services.AddSingleton&lt;FooClient&gt;();
    builder.Services.AddSingleton&lt;BarClient&gt;();
    builder.Services.AddTransient&lt;TopicResolver&gt;(topicProvider =&gt; key =&gt;
    {
        <span style=color:#0f0>// The key can be a string, Type, enum, int - whatever you need really
</span><span style=color:#0f0></span>        <span style=color:red>switch</span> (key)
        {
            <span style=color:red>case</span> <span style=color:#87ceeb>&#34;Foo&#34;</span>:
                <span style=color:red>return</span> topicProvider.GetService&lt;FooClient&gt;().TopicClient;
            <span style=color:red>case</span> <span style=color:#87ceeb>&#34;Bar&#34;</span>:
                <span style=color:red>return</span> topicProvider.GetService&lt;BarClient&gt;().TopicClient;
            <span style=color:red>default</span>:
                <span style=color:red>throw</span> <span style=color:red>new</span> KeyNotFoundException();
        }
    });
}
</code></pre></div><p>Let&rsquo;s me explain what&rsquo;s happening here. First we&rsquo;re registering our named clients as <a href=https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-performance-improvements#reusing-factories-and-clients><strong>singletons</strong></a> per the explanations and reasoning given in the documentation.</p>
<p>Next we register our <code>delegate</code> as a transient service that will return one of the topic clients we already registered based on a <code>key</code>. For my usage I use a <code>string</code> key stored inside the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.message.userproperties?view=azure-dotnet#Microsoft_Azure_ServiceBus_Message_UserProperties">message user properties</a>. Your <code>key</code> can be anything like <code>int</code>, <code>enum</code> or a specific <code>Type</code>.</p>
<p>Last thing we have to do is to put our <code>TopicResolver</code> to work!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:#0f0>// Code below uses a MediatR handler as an example
</span><span style=color:#0f0></span><span style=color:red>public</span> <span style=color:red>class</span> MessageHandler : IRequestHandler&lt;Message, <span style=color:violet>bool</span>&gt;
{
    <span style=color:red>private</span> <span style=color:red>readonly</span> TopicResolver topicResolver;

    <span style=color:red>public</span> MessageHandler(TopicResolver topicResolver)
    {
        <span style=color:red>this</span>.topicResolver = topicResolver ?? <span style=color:red>throw</span> <span style=color:red>new</span> ArgumentNullException(nameof(topicResolver));
    }

    <span style=color:red>public</span> <span style=color:red>async</span> Task&lt;<span style=color:violet>bool</span>&gt; Handle(Message msg, CancellationToken cancellationToken)
    {
        <span style=color:red>if</span> (msg == <span style=color:red>null</span>) <span style=color:red>throw</span> <span style=color:red>new</span> ArgumentNullException(nameof(msg));

        <span style=color:red>try</span>
        {
             <span style=color:#0f0>// Use a field from the user properties of the message as key
</span><span style=color:#0f0></span>             <span style=color:#0f0>// The client we get can be either FooClient or BarClient based on the value
</span><span style=color:#0f0></span>            <span style=color:violet>var</span> client = topicResolver(msg.UserProperties[<span style=color:#87ceeb>&#34;Key&#34;</span>]);
            <span style=color:red>await</span> client.SendAsync(msg);
            <span style=color:red>return</span> <span style=color:red>true</span>;
        }
        <span style=color:red>catch</span> (Exception ex)
        {
            <span style=color:red>return</span> <span style=color:red>false</span>;
        }
    }
}
</code></pre></div><p>As a bonus here&rsquo;s how to test if the <code>delegate</code> is doing it&rsquo;s job and verifying that the right client is called.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=color:red>using</span> System;
<span style=color:red>using</span> System.Threading.Tasks;
<span style=color:red>using</span> AutoFixture;
<span style=color:red>using</span> MediatR;
<span style=color:red>using</span> Microsoft.Azure.ServiceBus;
<span style=color:red>using</span> Moq;
<span style=color:red>using</span> Shouldly;
<span style=color:red>using</span> Xunit;

<span style=color:red>namespace</span> FooBarApp.Tests
{
    <span style=color:red>public</span> <span style=color:red>class</span> MessageHandlerTests
    {
        <span style=color:red>private</span> <span style=color:red>readonly</span> Mock&lt;TopicResolver&gt; topicResolver;
        <span style=color:red>private</span> <span style=color:red>readonly</span> Fixture fixture;
        <span style=color:red>private</span> IRequestHandler&lt;Message, <span style=color:violet>bool</span>&gt; sut;

        <span style=color:red>public</span> MessageHandlerTests()
        {
            topicResolver = <span style=color:red>new</span> Mock&lt;TopicResolver&gt;();
            fixture = <span style=color:red>new</span> Fixture();
        }

        [Fact]
        <span style=color:red>public</span> <span style=color:red>async</span> Task Handle_ValidMessageRequest_Foo_SendsMessage()
        {
            <span style=color:violet>var</span> message = fixture.Create&lt;Message&gt;();
            <span style=color:#0f0>// Best will be to create a customizer for different Messages
</span><span style=color:#0f0></span>            message.UserProperties.Add(<span style=color:#87ceeb>&#34;Key&#34;</span>, <span style=color:#87ceeb>&#34;Foo&#34;</span>);
            <span style=color:violet>var</span> client = <span style=color:red>new</span> Mock&lt;ITopicClient&gt;();

            topicResolver.Setup(x =&gt; x.Invoke(It.IsAny&lt;<span style=color:violet>string</span>&gt;()))
                .Returns(client.Object);

            sut = <span style=color:red>new</span> MessageHandler(topicResolver.Object);

            <span style=color:red>await</span> sut.Handle(message, <span style=color:red>default</span>);

            topicResolver.Verify(x =&gt; x(<span style=color:#87ceeb>&#34;Foo&#34;</span>), Times.Once);
            client.Verify((x =&gt; x.SendAsync(It.IsAny&lt;Message&gt;())), Times.Once);
        }

        [Fact]
        <span style=color:red>public</span> <span style=color:red>async</span> Task Handle_ValidMessageRequest_Bar_SendsMessage()
        {
            <span style=color:violet>var</span> message = fixture.Create&lt;Message&gt;();
            <span style=color:#0f0>// Best will be to create a customizer for different Messages
</span><span style=color:#0f0></span>            message.UserProperties.Add(<span style=color:#87ceeb>&#34;Key&#34;</span>, <span style=color:#87ceeb>&#34;Bar&#34;</span>);
            <span style=color:violet>var</span> client = <span style=color:red>new</span> Mock&lt;ITopicClient&gt;();

            topicResolver.Setup(x =&gt; x.Invoke(It.IsAny&lt;<span style=color:violet>string</span>&gt;()))
                .Returns(client.Object);

            sut = <span style=color:red>new</span> MessageHandler(topicResolver.Object);

            <span style=color:red>await</span> sut.Handle(message, <span style=color:red>default</span>);

            topicResolver.Verify(x =&gt; x(<span style=color:#87ceeb>&#34;Bar&#34;</span>), Times.Once);
            client.Verify((x =&gt; x.SendAsync(It.IsAny&lt;Message&gt;())), Times.Once);
        }
    }
}
</code></pre></div><p>And that&rsquo;s it! With this setup now you can add multiple topic clients with ease! Hope you find this post useful. There are other ways to accomplish the same thing and solve this problem, but I like this approach because it&rsquo;s extremely clean, elegant and testable!</p>
</article>
</div>
</main>
</body></html>