<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Publishing to Multiple Topics in Azure Service Bus | Pavel Danov</title>
    <link rel="stylesheet" href="https://underscorehao.net/css/style.css" />
    <link rel="stylesheet" href="https://underscorehao.net/css/fonts.css" />
    <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css" rel="stylesheet">

  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="https://underscorehao.net/">Home</a></li>
      
      <li><a href="https://underscorehao.net/categories/">Categories</a></li>
      
      <li><a href="https://underscorehao.net/tags/">Tags</a></li>
      
      <li><a href="https://underscorehao.net/about/">About</a></li>
      
      <li><a href="https://underscorehao.net/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Publishing to Multiple Topics in Azure Service Bus</span></h1>

<h2 class="date">2020/01/11</h2>

<p class="terms">

  
  Categories: <a href="https://underscorehao.net/categories/software-development">Software Development</a> 
  
  
  
  Tags: <a href="https://underscorehao.net/tags/c">c#</a> <a href="https://underscorehao.net/tags/.net">.net</a> <a href="https://underscorehao.net/tags/azure">azure</a> 
  
  
</p>
</div>


<nav id="TableOfContents">
  <ul>
    <li><a href="#multiple-topics">Multiple topics</a></li>
    <li><a href="#basic-setup">Basic Setup</a></li>
    <li><a href="#the-na誰ve-approach">The na誰ve approach</a></li>
    <li><a href="#introducing-the-itopicclient-resolver">Introducing the ITopicClient resolver</a></li>
  </ul>
</nav>


<main>
<h2 id="multiple-topics">Multiple topics</h2>
<p>There are two main approaches when it comes to topics in Azure Service Bus. Depending what&rsquo;s your architecture and needs you can have either:</p>
<ul>
<li><strong>Filtered topic</strong> - this means you have only one topic for all of your event types. All publishers push messages onto that single topic. Some of the message fields and properties are then used for filtering by the subscribers since in most cases a subscriber will be interested only in certain types of messages.</li>
<li><strong>Multiple topics</strong> - you have multiple topics for different domain events or channels of your system. You can still leverage the filtering to have more granular control in your subscribers. You can also have topics based on priority, event types etc.</li>
</ul>
<p>Our main concern in this post is the second use case and how to build a nice <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.topicclient?view=azure-dotnet"><strong><code>ITopicClient</code></strong></a> factory inside a .NET Core project. I&rsquo;ve built my example with Azure Functions, but 99.9% of the code is completely identical to what you would do in a normal .NET Core web service.</p>
<h2 id="basic-setup">Basic Setup</h2>
<p>If you haven&rsquo;t used <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.topicclient?view=azure-dotnet"><strong><code>ITopicClient</code></strong></a> and Azure Service Bus I recommend you read the following two articles before continuing:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-quickstart-topics-subscriptions-portal">Create Azure Service Bus topics and subscriptions</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions">Getting started with Service Bus topics</a></li>
</ul>
<p>Now that we know what libraries we&rsquo;ll be using we can start building our solution. The first step is to create our TopicClient which is easy enough</p>
<pre><code class="language-csharp">var topicClient = new TopicClient(&quot;AzureServiceBusConnectionString&quot;, &quot;TopicName&quot;);
</code></pre>
<p>The two things we need are the ASB connection string and the topic to which we would like to publish messages.</p>
<p>Let&rsquo;s get the boilerplate code that is going to be used onward out of the way first. You&rsquo;ll need to have something like that in your <code>appsettings.json</code> file</p>
<pre><code class="language-json">{
    &quot;ServiceBus&quot;: {
        &quot;Endpoint&quot;: &quot;AsbFooBarEndpoint&quot;,
        &quot;FooTopic&quot;: &quot;foo&quot;,
        &quot;BarTopic&quot;: &quot;bar&quot;
    }
}
</code></pre>
<p>And a simple POCO that you can map it to</p>
<pre><code class="language-csharp">public class ServiceBusOptions
{
    public string Endpoint { get; set; }

    public string FooTopic { get; set; }

    public string BarTopic { get; set; }
}
</code></pre>
<p>Then you register your options in the startup</p>
<pre><code class="language-csharp">private void BindConfigurationOptions(IServiceCollection services)
{
    services.Configure&lt;ServiceBusOptions&gt;(options =&gt;
        Configuration.GetSection(&quot;ServiceBus&quot;)
            .Bind(options));
}
</code></pre>
<h2 id="the-na誰ve-approach">The na誰ve approach</h2>
<p>If we were doing the first example (filtered topic) we are pretty much done. You can register your <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.topicclient?view=azure-dotnet"><strong><code>ITopicClient</code></strong></a> as a <a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-performance-improvements#reusing-factories-and-clients"><strong>singleton</strong></a> and inject it in your DI container.</p>
<pre><code class="language-csharp">// This is the Azure Functions host builder
// In a web service you'll have the IServiceCollection
public static void Configure(IFunctionsHostBuilder builder)
{
    builder.Services.AddSingleton&lt;ITopicClient&gt;(x =&gt;
    {
        var options = x.GetRequiredService&lt;IOptions&lt;ServiceBusOptions&gt;&gt;();
        return new new TopicClient(options.Value.Endpoint, options.Value.FooTopic);
    });
}
</code></pre>
<p>Finally you just use the injected client to send messages to the <code>Foo</code> topic</p>
<pre><code class="language-csharp">// Code below uses a MediatR handler as an example
public class FooHandler : IRequestHandler&lt;Foo, bool&gt;
{
    private readonly ITopicClient topicClient;

    public FooHandler(ITopicClient topicClient)
    {
        this.topicClient = topicClient ?? throw new ArgumentNullException(nameof(topicClient));
    }

    public async Task&lt;bool&gt; Handle(Foo request, CancellationToken cancellationToken)
    {
        if (request == null) throw new ArgumentNullException(nameof(request));

        try
        {
            await topicClient.SendAsync(request.Message);
            return true;
        }
        catch (Exception ex)
        {
            return false;
        }
    }
}
</code></pre>
<p>And that&rsquo;s that. We&rsquo;re done.</p>
<p>What happens however if we have to accommodate multiple topics? Do we inject multiple topics in the service/handler? Depending on your DI container are you even able to put multiple implementations of the same interface? Do we use a bunch of if statements and introduce cyclomatic complexity for deciding which topic client we want? These are all viable questions and solutions, but one elegant answer is hidden in the next section.</p>
<h2 id="introducing-the-itopicclient-resolver">Introducing the ITopicClient resolver</h2>
<p>In order to solve the problem at hand I want to minimize the complexity of dealing with multiple topics. I want the usage to be as simple as when using only one just like in the previous example. So how do we do that?</p>
<p>The first part of the problem is how to differentiate between the topic clients for each topic. We can do that by creating small wrapper classes around each client we have.</p>
<pre><code class="language-csharp">public class FooClient
{
    public readonly ITopicClient TopicClient;

    public FooClient(IOptions&lt;ServiceBusOptions&gt; options)
    {
        TopicClient = new TopicClient(options.Value.Endpoint, options.Value.FooTopic);
    }
}

public class BarClient
{
    public readonly ITopicClient TopicClient;

    public BarClient(IOptions&lt;ServiceBusOptions&gt; options)
    {
        TopicClient = new TopicClient(options.Value.Endpoint, options.Value.BarTopic);
    }
}
</code></pre>
<p>Now that we have our clients we are going to create a factory with the help of a <code>delegate</code>. Based on a <code>key</code> we&rsquo;ll return the exact topic client we want when we want it!</p>
<pre><code class="language-csharp">using Microsoft.Azure.ServiceBus;

namespace FooBarApp.Clients
{
    // The key can be a string, Type, enum, int - whatever you need really
    public delegate ITopicClient TopicResolver(string key);
}
</code></pre>
<p>The step where the magic happens is in our DI registration.</p>
<pre><code class="language-csharp">// This is the Azure Functions host builder
// In a web service you'll have the IServiceCollection
public static void Configure(IFunctionsHostBuilder builder)
{
    builder.Services.AddSingleton&lt;FooClient&gt;();
    builder.Services.AddSingleton&lt;BarClient&gt;();
    builder.Services.AddTransient&lt;TopicResolver&gt;(topicProvider =&gt; key =&gt;
    {
        // The key can be a string, Type, enum, int - whatever you need really
        switch (key)
        {
            case &quot;Foo&quot;:
                return topicProvider.GetService&lt;FooClient&gt;().TopicClient;
            case &quot;Bar&quot;:
                return topicProvider.GetService&lt;BarClient&gt;().TopicClient;
            default:
                throw new KeyNotFoundException();
        }
    });
}
</code></pre>
<p>Let&rsquo;s me explain what&rsquo;s happening here. First we&rsquo;re registering our named clients as <a href="https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-performance-improvements#reusing-factories-and-clients"><strong>singletons</strong></a> per the explanations and reasoning given in the documentation.</p>
<p>Next we register our <code>delegate</code> as a transient service that will return one of the topic clients we already registered based on a <code>key</code>. For my usage I use a <code>string</code> key stored inside the <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.servicebus.message.userproperties?view=azure-dotnet#Microsoft_Azure_ServiceBus_Message_UserProperties">message user properties</a>. Your <code>key</code> can be anything like <code>int</code>, <code>enum</code> or a specific <code>Type</code>.</p>
<p>Last thing we have to do is to put our <code>TopicResolver</code> to work!</p>
<pre><code class="language-csharp">// Code below uses a MediatR handler as an example
public class MessageHandler : IRequestHandler&lt;Message, bool&gt;
{
    private readonly TopicResolver topicResolver;

    public MessageHandler(TopicResolver topicResolver)
    {
        this.topicResolver = topicResolver ?? throw new ArgumentNullException(nameof(topicResolver));
    }

    public async Task&lt;bool&gt; Handle(Message msg, CancellationToken cancellationToken)
    {
        if (msg == null) throw new ArgumentNullException(nameof(msg));

        try
        {
             // Use a field from the user properties of the message as key
             // The client we get can be either FooClient or BarClient based on the value
            var client = topicResolver(msg.UserProperties[&quot;Key&quot;]);
            await client.SendAsync(msg);
            return true;
        }
        catch (Exception ex)
        {
            return false;
        }
    }
}
</code></pre>
<p>As a bonus here&rsquo;s how to test if the <code>delegate</code> is doing it&rsquo;s job and verifying that the right client is called.</p>
<pre><code class="language-csharp">using System;
using System.Threading.Tasks;
using AutoFixture;
using MediatR;
using Microsoft.Azure.ServiceBus;
using Moq;
using Shouldly;
using Xunit;

namespace FooBarApp.Tests
{
    public class MessageHandlerTests
    {
        private readonly Mock&lt;TopicResolver&gt; topicResolver;
        private readonly Fixture fixture;
        private IRequestHandler&lt;Message, bool&gt; sut;

        public MessageHandlerTests()
        {
            topicResolver = new Mock&lt;TopicResolver&gt;();
            fixture = new Fixture();
        }

        [Fact]
        public async Task Handle_ValidMessageRequest_Foo_SendsMessage()
        {
            var message = fixture.Create&lt;Message&gt;();
            // Best will be to create a customizer for different Messages
            message.UserProperties.Add(&quot;Key&quot;, &quot;Foo&quot;);
            var client = new Mock&lt;ITopicClient&gt;();

            topicResolver.Setup(x =&gt; x.Invoke(It.IsAny&lt;string&gt;()))
                .Returns(client.Object);

            sut = new MessageHandler(topicResolver.Object);

            await sut.Handle(message, default);

            topicResolver.Verify(x =&gt; x(&quot;Foo&quot;), Times.Once);
            client.Verify((x =&gt; x.SendAsync(It.IsAny&lt;Message&gt;())), Times.Once);
        }

        [Fact]
        public async Task Handle_ValidMessageRequest_Bar_SendsMessage()
        {
            var message = fixture.Create&lt;Message&gt;();
            // Best will be to create a customizer for different Messages
            message.UserProperties.Add(&quot;Key&quot;, &quot;Bar&quot;);
            var client = new Mock&lt;ITopicClient&gt;();

            topicResolver.Setup(x =&gt; x.Invoke(It.IsAny&lt;string&gt;()))
                .Returns(client.Object);

            sut = new MessageHandler(topicResolver.Object);

            await sut.Handle(message, default);

            topicResolver.Verify(x =&gt; x(&quot;Bar&quot;), Times.Once);
            client.Verify((x =&gt; x.SendAsync(It.IsAny&lt;Message&gt;())), Times.Once);
        }
    }
}
</code></pre>
<p>And that&rsquo;s it! With this setup now you can add multiple topic clients with ease! Hope you find this post useful. There are other ways to accomplish the same thing and solve this problem, but I like this approach because it&rsquo;s extremely clean, elegant and testable!</p>

</main>

  <footer>
  <script defer src="//yihui.org/js/math-code.js"></script>
<script defer src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script defer src="//yihui.org/js/center-img.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-106583563-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js" integrity="sha512-gU7kztaQEl7SHJyraPfZLQCNnrKdaQi5ndOyt4L4UPL/FHDd/uB9Je6KDARIqwnNNE27hnqoWLBq+Kpe4iHfeQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
hljs.configure({languages: []});
hljs.initHighlightingOnLoad();
</script>

  
  <hr/>
  息 <a href="mailto:underscorehao@gmail.com">Pavel Danov</a> 2017 &ndash; 2022 | <a href="https://github.com/underscoreHao/">Github</a> | <a href="https://twitter.com/underscoreHao">Twitter</a> | <a href="https://stackoverflow.com/users/2265179/underscorehao">StackOverflow</a> | <a href="https://www.linkedin.com/in/pavel-danov/">LinkedIn</a>
  
  </footer>
  </body>
</html>

