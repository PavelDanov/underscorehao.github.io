[{"content":"Why? The usefulness of this approach is debatable, but let me try to offer an answer on why you might want to know how to do that. I think it\u0026rsquo;s the mark of a good engineer to know what\u0026rsquo;s happening under the hood. Simple as that. New or inexperienced developers will benefit from understanding the connection between the user interface in Visual Studio and the actual command line tools used underneath.\nPrerequisites Imagine that you\u0026rsquo;re on Windows and want to use the MSVC compiler toolset from the command line to build a project with SFML. In a nutshell you\u0026rsquo;re going to replicate the documentation given for SFML and Visual Studio, but from the terminal.\nAssuming you have installed all the necessarry tooling and you have SFML in the C:\\libs\\SFML-2.5.1 directory you can just do the following.\nDynamic Linking # For DEBUG builds -d is part of the lib names. See SFML docs on that. cl Main.cpp Game.cpp Window.cpp \u0026quot;sfml-graphics-d.lib\u0026quot; \u0026quot;sfml-window-d.lib\u0026quot; \u0026quot;sfml-system-d.lib\u0026quot; \u0026quot;sfml-audio-d.lib\u0026quot; \u0026quot;sfml-network-d.lib\u0026quot; /I \u0026quot;C:\\libs\\SFML-2.5.1\\include\u0026quot; /MDd /link /LIBPATH:\u0026quot;C:\\libs\\SFML-2.5.1\\lib\u0026quot; /DEBUG  Let\u0026rsquo;s quickly break that down.\n After cl put your .cpp files, then add all .lib files because the linker will look for those. With /I you include the path to the SFML headers. Next is /MDd which is dealing with the runtime and adding additional debug information. We also need /link which is used to pass options to the linker and in this case we\u0026rsquo;re passing /LIBPATH which contains the path to the SFML libraries. Finally we pass /DEBUG to the linker because we\u0026rsquo;re doing a debug build in this case.  This will create a Main.exe in your current folder. You\u0026rsquo;ll need to add the appropriate SFML .dll files to that folder in order to execute your program successfully.\nStatic Linking For static linking the process is almost the same with some slight differences.\n# Note -s-d as part of the lib names. See SFML docs on that. cl Main.cpp Game.cpp Window.cpp \u0026quot;sfml-graphics-s-d.lib\u0026quot; \u0026quot;sfml-window-s-d.lib\u0026quot; \u0026quot;sfml-system-s-d.lib\u0026quot; \u0026quot;sfml-audio-s-d.lib\u0026quot; \u0026quot;sfml-network-s-d.lib\u0026quot; opengl32.lib freetype.lib winmm.lib gdi32.lib user32.lib Advapi32.lib /I \u0026quot;C:\\libs\\SFML-2.5.1\\include\u0026quot; /D SFML_STATIC /MDd /link /LIBPATH:\u0026quot;C:\\libs\\SFML-2.5.1\\lib\u0026quot; /DEBUG   This time we\u0026rsquo;re including the static version of the SFML libraries. We have to pass the extra dependencies needed by SFML in order for the build to be successful and not blow up with a lot of link errors. We use the /D flag to define the SFML_STATIC macro.  If all is well you\u0026rsquo;ll be able to just run your Main.exe straight away.\n Compiling a project with SFML in Vim\n  Final Words Learn to use CMake :)\n","permalink":"https://underscorehao.net/2021/11/compiling-cpp-sfml-windows-cli/","title":"Compiling C++ project using SFML with cl.exe"},{"content":"Introduction Hello dear visitor!\nBefore you stands a very long article in which you\u0026rsquo;ll find my review and results after spending 31 days with a book called Remembering Simplified Hanzi 1: How Not to Forget the Meaning and Writing of Chinese Characters written by James Heisig and Timothy W. Richardson. I think it\u0026rsquo;s a groundbreaking book and an amazing method because it broke down a certain wall that was hindering my desire and drive to learn the Chinese language for a long time.\nI\u0026rsquo;m no stranger to language learning having studied English, German and Russian in the past, but Chinese language was always an enigma for me, as I\u0026rsquo;m sure it is for most of the world!\nIn this text I\u0026rsquo;ve outlined my personal journey in trying to learn Chinese, as well as my experience with other languages.\nI understand that you might not care about this information, but I think it\u0026rsquo;s crucial so you can understand where I\u0026rsquo;m coming from and why the method introduced in the aforementioned book worked so well for me.\nThe book is based on the experience and method of James Heisig, who while visiting Japan for the first time years ago created the method and learned 1900 Kanji in a month with a full day of studying. My own data confirms his claim that the method (now refined after years) does work! I have learned 1500 Chinese characters in 31 days with less than 2 hours of studying every day while working full time as a Software Engineer.\nI can\u0026rsquo;t guarantee it\u0026rsquo;s going to work for you, but I can explain and show you why it worked for me! If you care only about the results, feel free to use the links at the top of the page in the Table of Contents, but I implore you to reconsider and read the whole article :)\nIf you\u0026rsquo;re not familiar with the method I strongly suggest before you start reading my review that you read the Introduction chapter of the book. A link to a sample and the first 6 chapters is freely available at the website of the university where James Heisig conducts research - you can find it in the references at the end 1.\nWith that being said, let\u0026rsquo;s begin!\nFirst encounters with 中文 I\u0026rsquo;ve been enamored with Chinese culture since I was a child. My very first memory of seeing Chinese characters is imprinted in my brain as if it was yesterday.\nThe story begins sometime in the mid 90\u0026rsquo;s when I was in kindergarten. My dad had an enormous book collection at the time and I raided it constantly in search for interesting things. I don\u0026rsquo;t remember if I could read at that point, but my hunt bore fruit every time I found a picture or illustration that could spin my imagination.\nOne day I was sifting through the mountains of books as I usually had done in the past and I encountered a book called Мифологический словарь (Mythological dictionary) 1. Bulgaria being a country of the former Warsaw Pact (and not an ex-Soviet republic as some people wrongly assume when I tell them where I\u0026rsquo;m from) had very close ties with the USSR. That meant that most Bulgarians interested in scientific topics had Russian books on these subjects. My father wasn\u0026rsquo;t an exception in this case. It\u0026rsquo;s not uncommon even to this day to find a lot of books in Russian in a majority of Bulgarian homes.\nBut I digress\u0026hellip;\nAs I was going through this book I looked at the paintings and illustrations that were in it. There were two pictures of what I now know are Jiang Ziya on a unicorn and Zhang Daoling on a tiger. Both of them looked like some powerful sorcerers to me. I hope you\u0026rsquo;ll agree that they look rather impressive! However, the most interesting thing to my young eyes in those paintings were the symbols on either side of them! I was immediately drawn to the Chinese characters. They looked magical and mysterious like nothing I\u0026rsquo;ve ever seen before. I don\u0026rsquo;t remember much after that, but I recall that I was trying to replicate these symbols on a piece of paper.\nIt\u0026rsquo;s been sort of a family joke since then that my fascination with the East has started with these two paintings at that exact moment. There\u0026rsquo;s definitely some truth in that!\n The wise Chinese sages - Jiang Ziya (left) and Zhang Daoling (right); Мифологический словарь p. 657\n  Great Wall of Characters A couple of years passed by and me now in the first or second grade saw me experience my first action movie starring Jackie Chan. The movie in question was Rumble in the Bronx. It was he who introduced me to martial arts and opened an entirely different world to me. That crazy jump between two buildings will be forever seared in my brain as one of the coolest things someone had ever done. If you haven\u0026rsquo;t watched it I strongly recommend it - it\u0026rsquo;s a classic!\nSoon after I found about Bruce Lee, Jet Li, Donnie Yen. Crouching Tiger, Hidden Dragon came out and the flying once more blew my mind!\nAfter nagging my mom for a long time, I finally attended my first karate lessons when I turned 10 years old.\nThe mysterious East was always a part of me from that point onwards. I\u0026rsquo;ve watched so much Asian (mainly Chinese and Japanese) cinema, watched anime, read books on history, culture and trained various eastern martial arts.\nI\u0026rsquo;ve had Chinese and Japanese phases of my fascination, but I never forgot that China was the source. That\u0026rsquo;s where those magical Chinese characters originated from.\nCompelling as they were to me though, I couldn\u0026rsquo;t make myself actually learn them. It seemed impossible to even try. My teenage self was thinking that Chinese and Japanese people can learn them all after years and years of diligent rote memorization - nothing else would work. There\u0026rsquo;s just an enormous amount of characters. And then you have to think about the pronunciation and grammar, and it seems like an impossible task the more and more you delve in it. Confronting the writing system was akin to standing in front of an impenetrable wall - a Great Wall of Characters if you will! It seemed insurmountable to climb through it.\nJames Heisig and Timothy W. Richardson the authors of Remembering Simplified Hanzi have this to say about my exact experience in the introduction of the book.\n To students approaching Chinese from a mother tongue written with an alphabet, the characters represent a forbidding obstacle, one that involves the memorization of thousands of complex configurations, each of which has to be tethered to a particular sound and a particular meaning or function. Focusing for the moment just on what is involved in trying to commit the written forms to memory, imagine yourself holding a kaleidoscope up to the light as still as possible, trying to fix in memory the particular pattern that the play of light and mirrors and colored stones has created. Chances are, your mind is unaccustomed to processing such material and it will take some time to organize the pattern for retention and recall. But let us suppose that you succeed after ten or fifteen minutes. You close your eyes, trace the pattern in your head, and then check your image against the original pattern, repeating the process until you are sure you have it committed to memory.\n  Then someone passes by and jars your elbow. The pattern is lost forever and in its place a new jumble appears. Immediately your memory begins to scramble. You set the kaleidoscope aside, sit down, and try to draw what you had just memorized, but to no avail. There is simply nothing left in memory to grab hold of. The characters are like that. One can sit at one’s desk and drill a number of characters for an hour or two, only to discover on the morrow that when something similar is seen, the former memory is erased or hopelessly confused by the new information. No wonder learners begin to think that they simply don’t have a good memory for characters, or decide that learning to write characters is not so important anyway 2\n I\u0026rsquo;ve started and given up trying to learn either Chinese or Japanese (based on the phase I was in) more times than I\u0026rsquo;d like to admit. This continued for years, until one day not very long ago I found that book and something finally clicked in my head. The path that I had to take revealed itself to me.\nTo understand this change of mindset however, I\u0026rsquo;ll have to share context on some of the other languages that I\u0026rsquo;ve learned during the years and how I approached them at the time. Presenting that information is important, because the conclusions from my small experiment with the Heisig method are based on that past experience just as much as with following the actual method.\nAs I am going through my own past language learning experience I\u0026rsquo;m going to list some of the biases around learning Chinese characters given in the Introduction by the authors of Remembering Simplified Hanzi.\nLearning (Indo-European) Languages My native Bulgarian language is an Indo-European language. Every other language I\u0026rsquo;ve tried to learn beside Chinese (Sino-Tibetan) and Japanese (Japonic) has been part of the same language family as my native Bulgarian.\nIn Bulgaria foreign language schools were (and still are) very popular so my parents enrolled me in a German language school when I started 1st grade. There I learned German for 7 years until the 7th grade. Since it was mandatory to choose a second language in the 5th grade I chose Russian and I studied it for 3 years.\nEnglish is the odd case in my language learning journey. English I haven\u0026rsquo;t studied anywhere officially (or seriously for that matter) aside from a small stint in a private academy before I was in the first grade and for a brief time in my new school when I switched schools in the 8th grade. To be honest I don\u0026rsquo;t remember any of it. By the time I was in the 8th grade English felt very natural to me.\nThe story of how I learned English weirds even myself sometimes, but that\u0026rsquo;s the way things are. I learned English via the following methods and completely passively at that:\n Being the curious child I was, I watched Discovery Channel all the time (at the time it was in English and subtitled in Bulgarian, nowadays everything is dubbed in Bulgarian). Doing this for years did wonders to my vocabulary. Hearing the same words over and over again made me subconsciously attach the translations from the subtitles to the words I\u0026rsquo;ve been hearing. Another big reason in the same vein was Cartoon Network, perhaps even before discovering Discovery Channel (sorry, a bad pun, I know). Dexter\u0026rsquo;s Laboratory, Samurai Jack, PPG, Ed, Edd \u0026amp; Eddy, Courage the Cowardly Dog and countless more shows. I knew most of their episodes by heart (still remember a lot of them). All of these programs were in English without subtitles. Essentially my TV watching habits when I was a child were Discovery Channel + Cartoon Network. One helped for attaining vocabulary and the other was pure comprehension. It was an approach that worked remarkably well. And last but not least. Internet and videogames. Playing games where you don\u0026rsquo;t understand anything was pretty fun still because, well, you\u0026rsquo;re playing a game! At some point after years and years of clicking stuff and watching/hearing what happens next I started to understand. Texts, dialogues. You can read without understanding half of the words, but just the act of reading unlocks your brain into absorbing the language.  So to summarize shortly - immersing yourself in a language will make you learn it! This is not contrary to popular advice at all. This is how small children learn their native tongue. I didn\u0026rsquo;t follow a rigorous studying pattern or anything like that. I was just a child watching interesting things on TV and playing computer games.\nThe interesting bit of my own experience and the reason I\u0026rsquo;m explaining all of this is the concrete combination of steps and how they flowed between each other subconsciously.\n Listening a foreign language and reading a translation of what\u0026rsquo;s being said in real-time. This adds to your vocabulary. Listening to a foreign language by itself. This combined with step 1 aids your comprehension ability. Reading the language combines both steps 1 and 2.  I\u0026rsquo;ve learned English on a higher level by myself than I ever did by learning German and Russian structurally in school by following the 3 steps above for years without even knowing it. This is perfectly captured by the authors when they write about how Chinese children already know the language by the time they start practicing characters.\n As children, they are exposed first to the spoken language, learning how to associate sounds with meanings. When the time comes to learn how to read, they already have at their disposal a solid basis of words whose sounds and meanings are familiar to them; all that remains is to associate those words with written forms. Doing so opens them to printed texts, which, in turn, helps them assimilate new words and characters. 2\n At school we were following the official study plan and it was basically cramming of grammar, vocabulary, listening and reading all at the same time. I have to tell you that it was painful. It was a very cumbersome system and a lot of language academies and systems follow the same approach to this day. It\u0026rsquo;s a commonly accepted way of learning a language and I\u0026rsquo;m sure it has helped me in some capacity in my journey of learning both languages (to a degree), but I\u0026rsquo;ve never been able to quantify it. It always seemed like a chore. Compare that with my natural way of learning English and there is a striking difference. Me learning English was not something I intended, it\u0026rsquo;s just something that happened.\nNow that I\u0026rsquo;m an adult I won\u0026rsquo;t be able to replicate that effect once more with a different language. I\u0026rsquo;m too aware now and I want quantifiable results and specific methods and patterns to follow.\nOne of the traps I\u0026rsquo;ve fallen into when starting to learn Chinese before was once again described in the Introduction of the book:\n One bias circulating among teachers and students of the Chinese language is that a character’s meaning, pronunciation, and writing need to be learned at the same time. Chinese textbooks typically include all three bits of information for each character or compound term as it is introduced, in addition to supplying details about grammatical function and examples of usage. Of course, these things are important, but to have to learn them all at once places an unreasonable burden on memory. Little wonder that the brain slows down or grinds to a complete halt. 2\n My own experience confirms this is true not only for learning Chinese but for learning German and Russian in school as well. Studying all these elements at the same time is just too much.\nThen the authors go even further and make the most important point (at least to me) in the entire book.\n Yet another bias that needs uprooting is the idea that characters can only be mastered through constant drill and repetition. Traditional methods for approaching the Chinese writing system have been the same as those for learning alphabets: practice writing the characters one by one, over and over again, for as long as it takes. Whatever ascetic value there is in such an exercise, it is hardly the most efficient way to approach character study. The reason this bias has such a strong hold on students of Chinese is that persons completely ignorant of the Chinese writing system naturally rely on teachers who have learned characters from childhood. Surely a pedagogy with many centuries of history behind it and over a billion users demands our respect.\n  Here again, the prevailing wisdom is deceptive. Native speakers of Chinese are clearly in a position to teach a good many things about their language, but they are not necessarily qualified to answer questions from non-native speakers about how best to learn the characters, for the simple reason that they themselves have never been in the situation of having to ask such a question. Having begun their study as children, in whom the powers of abstraction were not yet developed and for whom rote memory was the only option, they cannot be expected to fully grasp the learning potential an adult brings to the study of the characters. As children, we were all good imitators, with few habits to get in the way of our absorption of new skills. But we did not become good learners until we had the ability to classify, categorize, and organize discrete bits of information into larger blocks. This is precisely what young children cannot do with character forms and why they have no choice but to rely on imitation and repetition. Whatever educational and social advantages there may be to having an entire school population study Chinese characters by writing them again and again from an early age, for the adult approaching the language from the outside it amounts to little more than a gigantic waste of time. 2\n When in Rome (do as the Romans do) At this stage in the article it\u0026rsquo;s time for me to say that I learn best while reading. It\u0026rsquo;s my preferred method of knowledge transfer and I memorize the most information while doing it. If I\u0026rsquo;m learning a new language, reading is the most crucial bit and my own anecdotal experience with English confirms it. I could read English long before I understood even a portion of what I was reading. Same goes for German and Russian to a lesser extent. Reading without understanding has helped me enormously nonetheless.\nHowever, when it comes to learning a language without an alphabet like Chinese, things become a \u0026ldquo;bit\u0026rdquo; more complicated.\nIn Bulgarian for instance the hardest thing a foreigner will face if learning the language is the verb. There\u0026rsquo;s even a story about a famous Bulgarian linguist stating that \u0026ldquo;the verb is the elephant of Bulgarian grammar\u0026rdquo;. It\u0026rsquo;s very complex with a lot of nuances. In other languages you will have trouble with word pronunciation or the way a word is written and the way it\u0026rsquo;s spoken. A third problem might be that many words can have multiple meanings depending on the context. The list goes on and on.\nIn Chinese, the writing system is the most complicated thing to learn by far.\nLearning a new language is never easy, but the barrier to entry is much much lower when you only have to learn 24/30 symbols with which you can form words and sentences. This is the benefit of languages that use alphabets.\nChinese is on a whole different level. I don\u0026rsquo;t think it\u0026rsquo;s even fair to say level. It\u0026rsquo;s on a whole different dimension entirely! It\u0026rsquo;s by far the most different and has the highest barrier of entry for a native speaker of an Indo-European language. Perhaps it\u0026rsquo;s the hardest to learn by a representative of every other major language family as well. That Great Wall of Characters I mentioned at the start is safeguarding everyone in its borders from the outside world.\nFor me reading combines attaining vocabulary and comprehension, so for me to be able to say that I can read Chinese then I\u0026rsquo;ll have to know 8105 characters 3. Like the authors say that in itself is a forbidding obstacle.\nIt has taken me years of trying and failing to come to the conclusion of the authors which is that it\u0026rsquo;s probably a good idea to start with the hardest part - the abstract characters themselves. Not concerning myself with pronunciations or grammar, but on pure character learning.\nAs a Software Engineer I\u0026rsquo;m very logical and methodical in my work. I always try to break a problem down to the smallest possible logical unit, but it never occurred to me to look at language learning in such a way. I know it seems obvious, but the effects of my sudden realization were profound. I began following the Heisig method diligently and 31 days later I knew 1500 Chinese characters. And this was with me spending less than 2 hours a day on this endeavor while working fulltime from home (COVID-19).\nIf you begin methodically and follow the method diligently my own data confirms that it\u0026rsquo;s possible to learn 1500 Chinese characters in a month.\nPerhaps you\u0026rsquo;re still not convinced, but I hope to change your mind in the next section!\nCold Hard Data I know that probably you\u0026rsquo;re anxious at this point just to see the proof for my claims, but I want to share some light on the tools I\u0026rsquo;ve used and some on my previous Chinese character knowledge.\nI\u0026rsquo;ve tried to learn Chinese characters many times during the years. Some of the 1500 characters I encountered in the book I already knew. However, I followed the authors remarks in that specific case very carefully and I studied them again with the method completely for every character even if I knew it from before. I\u0026rsquo;d guess I probably knew around 100 of the characters I encountered and most of them were rather basic nouns for which it\u0026rsquo;s going to be easy to create a mental image either way.\nI also know the rules for stroke order of Chinese characters very well and I didn\u0026rsquo;t have any trouble with that having written most characters only 1 time when studying them. During reviews I\u0026rsquo;ve not written the characters over and over again which will defeat the purpose of following the method.\nMy review cards have only the keyword as an indication on them and it was part of my review to recall the primitives and the shape of the character. If both of these were correct and I could clearly see the character in my mind\u0026rsquo;s eye, then I deemed the review successful. If some primitives were missing or the position of an element was at the wrong place I considered that a mistake and marked it as such in Pleco (more on Pleco below).\n A copy of Remembering Simplified Hanzi - To me traditional Chinese characters look more beautiful and aesthetically pleasing, but in the interest of pragmatism I\u0026rsquo;ve chosen to learn simplified. They are simply more widespread. In my review software I see the simplified form and the traditional form as well and while reviewing I\u0026rsquo;ve already started to recognize and remember the shapes of some of the traditional characters. Take that information as you will. Pleco - This app is going to be by far the best software you can buy if you\u0026rsquo;re learning Chinese. It\u0026rsquo;s worth every penny. It\u0026rsquo;s a dictionary, stroke order animator, example sentences, OCR and many more features. Every module is worth the add-on price. I\u0026rsquo;ve used Pleco\u0026rsquo;s SRS (Spaced Repetition System) for my daily reviews. I have found a full card list for both tomes of Remembering Simplified Hanzi here. BE WARNED however that I\u0026rsquo;ve found an ordering issue that I\u0026rsquo;ve had to fix myself. In Lesson 30 of the card list, you\u0026rsquo;ll see two characters that in actuality will appear much later in the book. Both 用 with frame number [971] and 确 [972] have to be in Lesson 47 at frame numbers [1361] and [1362] respectively. Until then every character frame between lessons 30 and 47 is off by 2! I\u0026rsquo;m giving a link to my own fixed list which you can import in Pleco, but keep in mind that I don\u0026rsquo;t know if there\u0026rsquo;s a similar issue for the second book lists at this time. A piece of paper and a pen - write characters only once and you\u0026rsquo;ll remember them forever! Feels like magic! Calm mind - your brain is going to be the most important thing with this method (shocker, I know). I\u0026rsquo;ve done my studying in a very quiet and calm environment while in an extremely focused state. On days when I had too much work and felt tired or did my study session late you\u0026rsquo;ll see in the results that my performance was less than satisfactory (for example day 20 in the tables below). Actually I think if it wasn\u0026rsquo;t for day 20 I would\u0026rsquo;ve probably finished in less than 30 days :)  How have I structured my study plan? Essentially I\u0026rsquo;ve locked 3 slots during the day for reviews. One in the morning, one at noon and one in the evening. In each of these slots I did all reviews that Pleco gave me! My study slot varied between noon (in my lunch break from work) and evening for the most part, but the best results I got when studying in the morning before starting work.\nA final word on the way I kept timekeeping. I started a timer the moment I opened the book for study and stopped said timer the moment I closed the book. The reviews were timed by Pleco itself, so I\u0026rsquo;ve just combined both times to get the total.\nSo without further ado in this very long article already, let me finally show you some numbers and my actual review of the method.\nTime Data In 31 consecutive days I\u0026rsquo;ve spent:\n 38.72 hours in total of studying + reviewing 27.965 hours for studying 10.759 hours for reviewing 1.249 hours on average per day for studying + reviewing 99.673 seconds on average per character  Fig 1.1 - Time Spent learning/reviewing for 31 days    Day New Characters SPC (Seconds Per Character) Time      1 50 34.5 Time Spent Studying 24:30 minutes      Time Spent Reviewing 4:15 minutes      Time Spent Total 28:45 minutes   2 58 44 Time Spent Studying 35:53 minutes      Time Spent Reviewing 6:40 minutes      Time Spent Total 42:33 minutes   3 71 59.4 Time Spent Studying 60:07 minutes      Time Spent Reviewing 10:15 minutes      Time Spent Total 70:22 minutes   4 58 56.8 Time Spent Studying 45:01 minutes      Time Spent Reviewing 9:54 minutes      Time Spent Total 54:55 minutes   5 50 70.2 Time Spent Studying 51:03 minutes      Time Spent Reviewing 7:31 minutes      Time Spent Total 58:34 minutes   6 50 76.1 Time Spent Studying 44:50 minutes      Time Spent Reviewing 18:37 minutes      Time Spent Total 63:27 minutes   7 22 95.6 Time Spent Studying 16:03 minutes      Time Spent Reviewing 19:01 minutes      Time Spent Total 35:04 minutes   8 41 71.8 Time Spent Studying 40:42 minutes      Time Spent Reviewing 8:24 minutes      Time Spent Total 49:06 minutes   9 53 80.4 Time Spent Studying 46:53 minutes      Time Spent Reviewing 24:12 minutes      Time Spent Total 71:05 minutes   10 52 71.5 Time Spent Studying 40:39 minutes      Time Spent Reviewing 21:22 minutes      Time Spent Total 62:01 minutes   11 42 91.5 Time Spent Studying 43:37 minutes      Time Spent Reviewing 20:29 minutes      Time Spent Total 64:06 minutes   12 37 109.6 Time Spent Studying 39:00 minutes      Time Spent Reviewing 28:37 minutes      Time Spent Total 67:37 minutes   13 49 60.5 Time Spent Studying 48:47 minutes      Time Spent Reviewing 00:12 minutes      Time Spent Total 49:27 minutes   14 55 81.9 Time Spent Studying 54:06 minutes      Time Spent Reviewing 21:00 minutes      Time Spent Total 75:06 minutes   15 45 135.2 Time Spent Studying 55:42 minutes      Time Spent Reviewing 45:42 minutes      Time Spent Total 101:24 minutes   16 29 153.5 Time Spent Studying 34:24 minutes      Time Spent Reviewing 39:50 minutes      Time Spent Total 74:14 minutes   17 31 103.7 Time Spent Studying 35:35 minutes      Time Spent Reviewing 18:01 minutes      Time Spent Total 53:36 minutes   18 60 105 Time Spent Studying 80:00 minutes      Time Spent Reviewing 25:52 minutes      Time Spent Total 120:52 minutes   19 47 159.2 Time Spent Studying 60:31 minutes      Time Spent Reviewing 64:14 minutes      Time Spent Total 124:45 minutes   20 24 360.3 Time Spent Studying 83:45 minutes      Time Spent Reviewing 60:24 minutes      Time Spent Total 144:09 minutes   21 47 109 Time Spent Studying 60:21 minutes      Time Spent Reviewing 25:05 minutes      Time Spent Total 85:26 minutes   22 55 99.8 Time Spent Studying 64:31 minutes      Time Spent Reviewing 26:58 minutes      Time Spent Total 91:29 minutes   23 75 83.25 Time Spent Studying 94:10 minutes      Time Spent Reviewing 9:54 minutes      Time Spent Total 104:04 minutes   24 59 100.86 Time Spent Studying 87:19 minutes      Time Spent Reviewing 11:52 minutes      Time Spent Total 99:11 minutes   25 59 102.86 Time Spent Studying 75:49 minutes      Time Spent Reviewing 25:20 minutes      Time Spent Total 101:09 minutes   26 41 84.58 Time Spent Studying 50:12 minutes      Time Spent Reviewing 7:36 minutes      Time Spent Total 57:48 minutes   27 44 95.75 Time Spent Studying 53:18 minutes      Time Spent Reviewing 16:55 minutes      Time Spent Total 70:13 minutes   28 54 96.74 Time Spent Studying 62:09 minutes      Time Spent Reviewing 24:55 minutes      Time Spent Total 87:04 minutes   29 43 97.09 Time Spent Studying 50:49 minutes      Time Spent Reviewing 18:46 minutes      Time Spent Total 69:35 minutes   30 52 101.86 Time Spent Studying 76:50 minutes      Time Spent Reviewing 11:27 minutes      Time Spent Total 88:17 minutes   31 48 96.41 Time Spent Studying 65:23 minutes      Time Spent Reviewing 11:45 minutes      Time Spent Total 77:08 minutes    Character Data  1500 encountered characters (the entirety of the Remembering Simplified Hanzi book) 48.38 CPD (Characters Per Day) on average 95% average success rate from Pleco reviews 2867 character reviews in total in the course of 31 days  Fig 2.2 - Characters per day studied and review results    Day New Characters Total Encountered Characters Daily Reviews        1 50 50  Correct Incorrect Average Score      Morning Slot N/A N/A N/A      Noon Slot N/A N/A N/A      Evening Slot 50 0 100%   2 57 107  Correct Incorrect Average Score      Morning Slot N/A N/A N/A      Noon Slot 57 0 100%      Evening Slot N/A N/A N/A   3 71 178  Correct Incorrect Average Score      Morning Slot N/A N/A N/A      Noon Slot 71 0 100%      Evening Slot N/A N/A N/A   4 58 236  Correct Incorrect Average Score      Morning Slot N/A N/A N/A      Noon Slot 58 0 100%      Evening Slot N/A N/A N/A   5 50 286  Correct Incorrect Average Score      Morning Slot N/A N/A N/A      Noon Slot 50 0 100%      Evening Slot N/A N/A N/A   6 50 336  Correct Incorrect Average Score      Morning Slot 50 0 100%      Noon Slot 86 0 100%      Evening Slot N/A N/A N/A   7 22 358  Correct Incorrect Average Score      Morning Slot 21 2 90%      Noon Slot N/A N/A N/A      Evening Slot 92 0 100%   8 41 399  Correct Incorrect Average Score      Morning Slot N/A N/A N/A      Noon Slot 43 0 100%      Evening Slot N/A N/A N/A   9 53 452  Correct Incorrect Average Score      Morning Slot 59 0 100%      Noon Slot 49 1 98%      Evening Slot N/A N/A N/A   10 52 504  Correct Incorrect Average Score      Morning Slot 1 0 100%      Noon Slot 104 1 99%      Evening Slot N/A N/A N/A   11 42 546  Correct Incorrect Average Score      Morning Slot 48 2 96%      Noon Slot 43 0 100%      Evening Slot N/A N/A N/A   12 37 583  Correct Incorrect Average Score      Morning Slot 22 1 95%      Noon Slot 42 3 93%      Evening Slot 37 2 94%   13 49 632  Correct Incorrect Average Score      Morning Slot N/A N/A N/A      Noon Slot 1 0 100%      Evening Slot 3 0 100%   14 55 687  Correct Incorrect Average Score      Morning Slot 3 0 100%      Noon Slot N/A N/A N/A      Evening Slot 101 2 98%   15 45 732  Correct Incorrect Average Score      Morning Slot N/A N/A N/A      Noon Slot 97 8 92%      Evening Slot 60 0 100%   16 29 761  Correct Incorrect Average Score      Morning Slot 1 0 100%      Noon Slot N/A N/A N/A      Evening Slot 137 14 90%   17 31 792  Correct Incorrect Average Score      Morning Slot 36 2 94%      Noon Slot 31 0 100%      Evening Slot N/A N/A N/A   18 60 852  Correct Incorrect Average Score      Morning Slot 104 6 94%      Noon Slot 4 0 100%      Evening Slot 1 0 100%   19 47 899  Correct Incorrect Average Score      Morning Slot 14 2 87%      Noon Slot 86 7 92%      Evening Slot 108 9 92%   20 24 923  Correct Incorrect Average Score      Morning Slot 38 16 70%      Noon Slot 2 0 100%      Evening Slot 71 19 78%   21 47 970  Correct Incorrect Average Score      Morning Slot 12 0 100%      Noon Slot 12 4 75%      Evening Slot 30 4 88%   22 55 1025  Correct Incorrect Average Score      Morning Slot 56 5 91%      Noon Slot 46 1 97%      Evening Slot 20 1 95%   23 75 1100  Correct Incorrect Average Score      Morning Slot N/A N/A N/A      Noon Slot 58 0 100%      Evening Slot 2 0 100%   24 59 1159  Correct Incorrect Average Score      Morning Slot 2 0 100%      Noon Slot 22 0 100%      Evening Slot 38 0 100%   25 59 1218  Correct Incorrect Average Score      Morning Slot 50 1 98%      Noon Slot 97 2 97%      Evening Slot 2 0 100%   26 41 1259  Correct Incorrect Average Score      Morning Slot 10 1 90%      Noon Slot 20 1 95%      Evening Slot 20 1 95%   27 44 1303  Correct Incorrect Average Score      Morning Slot 69 2 97%      Noon Slot 6 1 85%      Evening Slot 5 2 71%   28 54 1357  Correct Incorrect Average Score      Morning Slot 73 2 97%      Noon Slot 34 0 100%      Evening Slot 11 0 100%   29 43 1400  Correct Incorrect Average Score      Morning Slot 5 1 83%      Noon Slot 58 1 98%      Evening Slot 10 2 83%   30 52 1452  Correct Incorrect Average Score      Morning Slot 21 2 91%      Noon Slot 7 0 100%      Evening Slot 12 0 100%   31 48 1500  Correct Incorrect Average Score      Morning Slot 5 0 100%      Noon Slot 34 6 85%      Evening Slot 2 0 100%    The Heisig Method So as you see, I\u0026rsquo;ve had a transformative experience in the past month. I went from a person that had tried to learn Chinese characters for many years to someone finally finding a method that works. It\u0026rsquo;s an interesting question if The Heisig Method will work for you. But it definitely worked for me. In this section I\u0026rsquo;m going to describe some interesting points and some pain points I\u0026rsquo;ve found along the way.\nFirst of all I\u0026rsquo;d like to say that I followed the advice in the book and I was learning just the characters as isolated pictographic units. That means I only studied the keyword + primitives and the ability to recall how to write the character based on them. That\u0026rsquo;s as far as I went when active learning is concerned. As I mentioned in the previous section I reviewed based on the given keyword alone because that was the authors advice. I saw pronunciation on the answer side of my cards and I repeat it, but I didn\u0026rsquo;t do anything more. Same goes for the traditional form of the characters. I saw them on the answer side, but I made no effort to memorize them.\nThe reasoning for that is described very well in the introduction of the book. I agree with it completely at this point (as stated before), especially when taking into account my previous language learning experience. Learning characters + pronunciation + grammar + listening at the same time seems to me like a huge waste of time and very hard and time consuming. There\u0026rsquo;s too much ambiguity in the syllables. The authors tell us:\n For example, even an ordinary pocket dictionary of Mandarin lists some 60 characters that are pronounced yi in one or another of its tonal variants, with at least 30 distinct characters in the fourth tone alone. 2\n I\u0026rsquo;m not a native speaker of the language and I\u0026rsquo;m not surrounded by it. I don\u0026rsquo;t have time to do it the way Chinese people do it.\nI, just like the authors agree that this method has drawbacks especially when you consider that most words in Chinese use 2 or 3 characters. BUT this method is not for learning vocabulary! It\u0026rsquo;s for learning how to write and how to remember to write 3000 Chinese characters (2 books of 1500 chars).\nLet\u0026rsquo;s say that I keep at this current rate and finish the second book in around 2 months time. Then I can actually start to read even though I won\u0026rsquo;t understand anything (the vocabulary problem). But just the act of recognition when you encounter a foreign text is a huge boon to any learning. I would be able to delve deeper into the grammar and just learn vocabulary without wasting time on learning the characters I encounter. It\u0026rsquo;s going to help me to do much more focused learning based on specific topics that I want to learn about. I\u0026rsquo;ll also be able to assign the pronunciations to the characters and practice them while listening. Like the authors have said, characters remove the ambiguity of the pronunciation.\nEven then my results show that if you can focus for deep work for 2 hours a day you can learn 50 characters each day. If we extend that for 4 hours without outside interference theoretically it should be possible to be able to learn a 100 characters a day! I\u0026rsquo;m not sure how does that look like, but if I had the time I\u0026rsquo;d certainly try it!\nAt this stage I\u0026rsquo;m a strong proponent of the idea that big problems like learning Chinese should be broken down into the smallest and most logical unit that works for you as an individual. The authors have completely converted me. For me that means learning how to recognize as many characters as I can at first and take everything else from there.\nAssociations galore The Heisig Method is interesting to me because I have an additional challenge in the fact that I\u0026rsquo;m not a native English speaker, so some of the keywords that were given were English words that I didn\u0026rsquo;t know. It wasn\u0026rsquo;t a huge number of words, but I had to check up their meanings to be able to form a clear picture.\nFor example the keyword resplendent. I don\u0026rsquo;t think I\u0026rsquo;ve encountered it anywhere during the years (or maybe I have, but just forgotten it). Once I saw the actual English meaning and how the character that\u0026rsquo;s assigned to it is built, it became clear in an instant. The character for resplendent is 煌 and is built from 火 (fire) + 皇 (emperor). The first association that popped in my mind when I read \u0026ldquo;fire\u0026hellip; emperor\u0026rdquo; was of Firelord Ozai from The Last Airbender. The association in my mind was so strong that it\u0026rsquo;s one of those that I\u0026rsquo;ll never forget. In an instant I knew that I \u0026ldquo;knew\u0026rdquo; this character forever alongside the English meaning of the key word. I had a super clear mental image in my mind. Other interesting words that I didn\u0026rsquo;t really know where auspicious, adroit and venerate. I\u0026rsquo;ve made concrete images for all of them after reading on their actual meaning. It\u0026rsquo;s nice when learning one language helps you with another and they both complement each other.\n The \u0026lsquo;resplendent\u0026rsquo; Fire Lord Ozai in \u0026lsquo;The Last Airbender\u0026rsquo; - One of the greatest animated shows ever made\n  Obviously not all keywords are that easy, especially some more abstract ones where stories get a bit more involved. I even think that rote memorization of the primitives + keyword themselves is still going to be a faster method than pure muscle memory training of writing the character over and over again. Maybe it\u0026rsquo;s just easy for me to create mental stories and images, but cases just like resplendent are not uncommon. I just try to create an emotional response/story from the keyword + primitives combination. Most characters I write only once and because I know the primitives they\u0026rsquo;re fixed in my memory. I had no trouble in remembering their stroke order or position of the elements (there are exceptions, but few and far between).\nLet me give another example of a primitive that exists in a number of other characters and how my association with it works. The primitive taskmaster is 攵. When I initially read that explanation I immediately thought of Tony Soprano. I am a huge fan of the show so it\u0026rsquo;s an association that came very naturally to me. Tony was the boss! Let\u0026rsquo;s see how did I construct my stories with that primitive:\n 攻 - with keyword attack = I-beam + taskmaster; Tony Soprano bashing someone\u0026rsquo;s head in with an I-beam 救 - with keyword rescue = request + taskmaster; Tony Soprano rushing into the pool to rescue his son AJ from suicide by drowning (very poorly planned and executed on his part if I might add\u0026hellip;) while AJ is requesting (left part of the character) help 敬 - with keyword revere = flower + sentence + taskmaster; A mob goon pleading with Tony via flowery sentences (left part of the character)  I know this may seem a bit graphic and gruesome, but the point here is that these images drive the point home very effectively. They create an emotional response for me and that\u0026rsquo;s why the characters were so easy to remember.\nAnd that\u0026rsquo;s how the whole method works! You start with the simplest of characters, the character for 一 (one) and you go from there by adding more and more elements which can also become primitives to other more complicated characters. In example the character for revere which I\u0026rsquo;ve shown above will become a primitive in the more complex character 警 which has the keyword police.\nAll of this is very logical and gradual! It\u0026rsquo;s like writing a computer program, where you just add different modules and libraries together and increase the abstraction and complexity with time.\n Tony Soprano as portrayed by the late great James Gandolfini\n  I can continue on and on and make a list of the stories for every character, but you must understand that these stories work for me exactly because they\u0026rsquo;re mine. After the first couple of chapters some of the stories that the authors provided weren\u0026rsquo;t very helpful. Baseball references or some vague religious analogies in those introductory stories didn\u0026rsquo;t make too much sense to me. For those instances I\u0026rsquo;ve completely disregarded the author\u0026rsquo;s stories and created my own. And in the end that is the method - you create your own stories that evoke a strong emotion and a mental image based on your own experience.\nConclusion As final words I\u0026rsquo;d like to say that The Heisig Method worked extremely well for me, but there\u0026rsquo;s no guarantee it\u0026rsquo;s going to work for you.\nWe\u0026rsquo;re all unique and memorize things differently. With that being said though, I do think there\u0026rsquo;s a huge benefit in cracking the writing system first before you go on forward. I agree with the authors wholeheartedly on that front.\nI\u0026rsquo;ve seen the figures of 2200 and 4400 hours being thrown 4 as the amount of hours needed for an English speaker to learn Chinese fluently. If we take even the lower figure as real, I wonder how much time they\u0026rsquo;ve used that on character learning?\nLet\u0026rsquo;s do some simple math of how long it\u0026rsquo;s going to take you conservatively to learn the 8105 characters given in the Table of General Standard Chinese Characters if you follow my velocity of 50 characters a day. And I\u0026rsquo;m going to add another 30 minutes, so we have 2 whole hours a day.\n 8105 (total characters) / 50 (characters per day) = 162.1 days ~ 6 months\n  162.1 (days) * 2 (hours) = 324.2‬ hours\n 324.2 hours for all characters in the course of ~6 months. This seems very possible to me and a very good investment of time at that. After these 6 months you\u0026rsquo;ll be free to pursue gaining vocabulary in the form of combining the characters you know into words, pronunciation and listening/speaking.\nAnd perhaps I\u0026rsquo;ll embark on that journey myself :)\nI thank you for your time if you\u0026rsquo;ve come down this far! I know the article is really long, but I wanted to share my experience and results exactly as they happened in the hope that this information can help other people that are having similar struggles. I\u0026rsquo;d be interested in your results if you\u0026rsquo;ve tackled character learning via the same method yourself! You can find my contact details on the footer of this page.\nThank you once again!\n  Мифологический словарь - Full book is linked under the Издание section\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Remembering Simplified Hanzi 1: How Not to Forget the Meaning and Writing of Chinese Characters - pages 1-4 from the Introduction chapter.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Table of General Standard Chinese Characters\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n United States Foreign Service Institute\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://underscorehao.net/2020/05/learning-1500-chinese-characters-in-a-month-heisig-method-review/","title":"How I learned 1500 Chinese Characters in a Month - Heisig Method Review"},{"content":"Multiple topics There are two main approaches when it comes to topics in Azure Service Bus. Depending what\u0026rsquo;s your architecture and needs you can have either:\n Filtered topic - this means you have only one topic for all of your event types. All publishers push messages onto that single topic. Some of the message fields and properties are then used for filtering by the subscribers since in most cases a subscriber will be interested only in certain types of messages. Multiple topics - you have multiple topics for different domain events or channels of your system. You can still leverage the filtering to have more granular control in your subscribers. You can also have topics based on priority, event types etc.  Our main concern in this post is the second use case and how to build a nice ITopicClient factory inside a .NET Core project. I\u0026rsquo;ve built my example with Azure Functions, but 99.9% of the code is completely identical to what you would do in a normal .NET Core web service.\nBasic Setup If you haven\u0026rsquo;t used ITopicClient and Azure Service Bus I recommend you read the following two articles before continuing:\n Create Azure Service Bus topics and subscriptions Getting started with Service Bus topics  Now that we know what libraries we\u0026rsquo;ll be using we can start building our solution. The first step is to create our TopicClient which is easy enough\nvar topicClient = new TopicClient(\u0026quot;AzureServiceBusConnectionString\u0026quot;, \u0026quot;TopicName\u0026quot;);  The two things we need are the ASB connection string and the topic to which we would like to publish messages.\nLet\u0026rsquo;s get the boilerplate code that is going to be used onward out of the way first. You\u0026rsquo;ll need to have something like that in your appsettings.json file\n{ \u0026quot;ServiceBus\u0026quot;: { \u0026quot;Endpoint\u0026quot;: \u0026quot;AsbFooBarEndpoint\u0026quot;, \u0026quot;FooTopic\u0026quot;: \u0026quot;foo\u0026quot;, \u0026quot;BarTopic\u0026quot;: \u0026quot;bar\u0026quot; } }  And a simple POCO that you can map it to\npublic class ServiceBusOptions { public string Endpoint { get; set; } public string FooTopic { get; set; } public string BarTopic { get; set; } }  Then you register your options in the startup\nprivate void BindConfigurationOptions(IServiceCollection services) { services.Configure\u0026lt;ServiceBusOptions\u0026gt;(options =\u0026gt; Configuration.GetSection(\u0026quot;ServiceBus\u0026quot;) .Bind(options)); }  The naïve approach If we were doing the first example (filtered topic) we are pretty much done. You can register your ITopicClient as a singleton and inject it in your DI container.\n// This is the Azure Functions host builder // In a web service you'll have the IServiceCollection public static void Configure(IFunctionsHostBuilder builder) { builder.Services.AddSingleton\u0026lt;ITopicClient\u0026gt;(x =\u0026gt; { var options = x.GetRequiredService\u0026lt;IOptions\u0026lt;ServiceBusOptions\u0026gt;\u0026gt;(); return new new TopicClient(options.Value.Endpoint, options.Value.FooTopic); }); }  Finally you just use the injected client to send messages to the Foo topic\n// Code below uses a MediatR handler as an example public class FooHandler : IRequestHandler\u0026lt;Foo, bool\u0026gt; { private readonly ITopicClient topicClient; public FooHandler(ITopicClient topicClient) { this.topicClient = topicClient ?? throw new ArgumentNullException(nameof(topicClient)); } public async Task\u0026lt;bool\u0026gt; Handle(Foo request, CancellationToken cancellationToken) { if (request == null) throw new ArgumentNullException(nameof(request)); try { await topicClient.SendAsync(request.Message); return true; } catch (Exception ex) { return false; } } }  And that\u0026rsquo;s that. We\u0026rsquo;re done.\nWhat happens however if we have to accommodate multiple topics? Do we inject multiple topics in the service/handler? Depending on your DI container are you even able to put multiple implementations of the same interface? Do we use a bunch of if statements and introduce cyclomatic complexity for deciding which topic client we want? These are all viable questions and solutions, but one elegant answer is hidden in the next section.\nIntroducing the ITopicClient resolver In order to solve the problem at hand I want to minimize the complexity of dealing with multiple topics. I want the usage to be as simple as when using only one just like in the previous example. So how do we do that?\nThe first part of the problem is how to differentiate between the topic clients for each topic. We can do that by creating small wrapper classes around each client we have.\npublic class FooClient { public readonly ITopicClient TopicClient; public FooClient(IOptions\u0026lt;ServiceBusOptions\u0026gt; options) { TopicClient = new TopicClient(options.Value.Endpoint, options.Value.FooTopic); } } public class BarClient { public readonly ITopicClient TopicClient; public BarClient(IOptions\u0026lt;ServiceBusOptions\u0026gt; options) { TopicClient = new TopicClient(options.Value.Endpoint, options.Value.BarTopic); } }  Now that we have our clients we are going to create a factory with the help of a delegate. Based on a key we\u0026rsquo;ll return the exact topic client we want when we want it!\nusing Microsoft.Azure.ServiceBus; namespace FooBarApp.Clients { // The key can be a string, Type, enum, int - whatever you need really public delegate ITopicClient TopicResolver(string key); }  The step where the magic happens is in our DI registration.\n// This is the Azure Functions host builder // In a web service you'll have the IServiceCollection public static void Configure(IFunctionsHostBuilder builder) { builder.Services.AddSingleton\u0026lt;FooClient\u0026gt;(); builder.Services.AddSingleton\u0026lt;BarClient\u0026gt;(); builder.Services.AddTransient\u0026lt;TopicResolver\u0026gt;(topicProvider =\u0026gt; key =\u0026gt; { // The key can be a string, Type, enum, int - whatever you need really switch (key) { case \u0026quot;Foo\u0026quot;: return topicProvider.GetService\u0026lt;FooClient\u0026gt;().TopicClient; case \u0026quot;Bar\u0026quot;: return topicProvider.GetService\u0026lt;BarClient\u0026gt;().TopicClient; default: throw new KeyNotFoundException(); } }); }  Let\u0026rsquo;s me explain what\u0026rsquo;s happening here. First we\u0026rsquo;re registering our named clients as singletons per the explanations and reasoning given in the documentation.\nNext we register our delegate as a transient service that will return one of the topic clients we already registered based on a key. For my usage I use a string key stored inside the message user properties. Your key can be anything like int, enum or a specific Type.\nLast thing we have to do is to put our TopicResolver to work!\n// Code below uses a MediatR handler as an example public class MessageHandler : IRequestHandler\u0026lt;Message, bool\u0026gt; { private readonly TopicResolver topicResolver; public MessageHandler(TopicResolver topicResolver) { this.topicResolver = topicResolver ?? throw new ArgumentNullException(nameof(topicResolver)); } public async Task\u0026lt;bool\u0026gt; Handle(Message msg, CancellationToken cancellationToken) { if (msg == null) throw new ArgumentNullException(nameof(msg)); try { // Use a field from the user properties of the message as key // The client we get can be either FooClient or BarClient based on the value var client = topicResolver(msg.UserProperties[\u0026quot;Key\u0026quot;]); await client.SendAsync(msg); return true; } catch (Exception ex) { return false; } } }  As a bonus here\u0026rsquo;s how to test if the delegate is doing it\u0026rsquo;s job and verifying that the right client is called.\nusing System; using System.Threading.Tasks; using AutoFixture; using MediatR; using Microsoft.Azure.ServiceBus; using Moq; using Shouldly; using Xunit; namespace FooBarApp.Tests { public class MessageHandlerTests { private readonly Mock\u0026lt;TopicResolver\u0026gt; topicResolver; private readonly Fixture fixture; private IRequestHandler\u0026lt;Message, bool\u0026gt; sut; public MessageHandlerTests() { topicResolver = new Mock\u0026lt;TopicResolver\u0026gt;(); fixture = new Fixture(); } [Fact] public async Task Handle_ValidMessageRequest_Foo_SendsMessage() { var message = fixture.Create\u0026lt;Message\u0026gt;(); // Best will be to create a customizer for different Messages message.UserProperties.Add(\u0026quot;Key\u0026quot;, \u0026quot;Foo\u0026quot;); var client = new Mock\u0026lt;ITopicClient\u0026gt;(); topicResolver.Setup(x =\u0026gt; x.Invoke(It.IsAny\u0026lt;string\u0026gt;())) .Returns(client.Object); sut = new MessageHandler(topicResolver.Object); await sut.Handle(message, default); topicResolver.Verify(x =\u0026gt; x(\u0026quot;Foo\u0026quot;), Times.Once); client.Verify((x =\u0026gt; x.SendAsync(It.IsAny\u0026lt;Message\u0026gt;())), Times.Once); } [Fact] public async Task Handle_ValidMessageRequest_Bar_SendsMessage() { var message = fixture.Create\u0026lt;Message\u0026gt;(); // Best will be to create a customizer for different Messages message.UserProperties.Add(\u0026quot;Key\u0026quot;, \u0026quot;Bar\u0026quot;); var client = new Mock\u0026lt;ITopicClient\u0026gt;(); topicResolver.Setup(x =\u0026gt; x.Invoke(It.IsAny\u0026lt;string\u0026gt;())) .Returns(client.Object); sut = new MessageHandler(topicResolver.Object); await sut.Handle(message, default); topicResolver.Verify(x =\u0026gt; x(\u0026quot;Bar\u0026quot;), Times.Once); client.Verify((x =\u0026gt; x.SendAsync(It.IsAny\u0026lt;Message\u0026gt;())), Times.Once); } } }  And that\u0026rsquo;s it! With this setup now you can add multiple topic clients with ease! Hope you find this post useful. There are other ways to accomplish the same thing and solve this problem, but I like this approach because it\u0026rsquo;s extremely clean, elegant and testable!\n","permalink":"https://underscorehao.net/2020/01/publishing-to-multiple-topics-in-azure-service-bus/","title":"Publishing to Multiple Topics in Azure Service Bus"},{"content":"Caching is hard On a bright sunny day while you\u0026rsquo;re working on your awesome project you catch a glimpse of something. You bring yourself closer to the monitor and begin meticulously examining your code. What you find brings you feelings of disgust and shame! You\u0026rsquo;ve been calling an API retrieving data you need over and over again even though said data hardly changes!\nBeing the smart and responsible engineer that you are, you decide to rectify your mistake immediately. You think to yourself\n \u0026ldquo;OK, I\u0026rsquo;ll just implement caching around that piece of data and I\u0026rsquo;m done!\u0026rdquo;\n Not so fast! Little do you know that you\u0026rsquo;re opening the gates of your own small personal hell!\nCaching in .NET The little story above is a slight exaggeration, but caching is indeed a touchy subject. It\u0026rsquo;s a nice performance boost when done right, but it can also lead you to a dark path filled with scary monsters and unforeseen problems.\nThere are many articles written on caching in .NET, you should read the official docs and perhaps other articles written by the good people on the Internet.\nThis article however will deal with a very specific caching problem. How can you implement a cache that is refreshing itself after a specific amount of time with the following characteristics:\n Thread safety Not getting any cache misses (even if that means we\u0026rsquo;re returning stale data)  If that\u0026rsquo;s what you need, keep on reading!\nImplementation with MemoryCache in .NET Framework Let\u0026rsquo;s start with the simple stuff. We want to perform some basic CRUD operations on our cache - saving data to it, getting our cached objects and potentially deleting our data. The best way to do it is to define an interface.\nusing System.Runtime.Caching;\rnamespace FooBar.Caching\r{\rpublic interface IMemoryAutoRefreshCache\r{\rT GetById\u0026lt;T\u0026gt;(string id);\rvoid Save\u0026lt;T\u0026gt;(string id, T cacheObj, CacheItemPolicy refreshPolicy);\rvoid Remove(string id);\r}\r}\r These are the methods I\u0026rsquo;m going to use to illustrate my example. Depending on your use case you can have a lot more of them doing various things to your cache, but for my case those are enough. The point I want you to focus on here is the CacheItemPolicy we can set during the Save.\nNow that we have our interface we can also implement it in a new class\nusing System.Runtime.Caching;\rnamespace FooBar.Caching\r{\rpublic class MemoryAutoRefreshCache : IMemoryAutoRefreshCache\r{\rprivate readonly MemoryCache memoryCache;\rpublic MemoryAutoRefreshCache(MemoryCache memoryCache = null) =\u0026gt; this.memoryCache = memoryCache ?? MemoryCache.Default;\rpublic T GetById\u0026lt;T\u0026gt;(string id)\r{\rvar value = (T)memoryCache.Get(id);\rif (value == null)\r{\rreturn default(T);\r}\rreturn value;\r}\rpublic void Save\u0026lt;T\u0026gt;(string id, T result, CacheItemPolicy refreshPolicy)\r{\rmemoryCache.Set(id, result, refreshPolicy);\r}\rpublic void Remove(string id)\r{\rmemoryCache.Remove(id);\r}\r}\r}\r Nothing out of the ordinary here. I want to bring your attention to our Save method one more time and the CacheItemPolicy. The summary of CacheItemPolicy states:\n Represents a set of eviction and expiration details for a specific cache entry.\n Inside the CacheItemPolicy we have two callbacks which will give us everything we need to accomplish our task.\n RemovedCallback - Occurs after the item has been removed UpdateCallback - Occurs before the item is removed  As you can imagine we\u0026rsquo;ll use the UpdateCallback in our case.\nSo let\u0026rsquo;s see how an implementation of this auto refreshing cache will look like!\nusing System;\rusing System.Runtime.Caching;\rusing System.Threading;\rusing FooBar.Caching;\rnamespace FooBar.Services.Configuration\r{\rpublic class ConfigurationProvider\r{\rprivate readonly IMemoryAutoRefreshCache localCache;\rprivate const string cacheKey = \u0026quot;myAwesomeCacheKey\u0026quot;;\rprivate static readonly object _lock = new object();\rpublic ConfigurationProvider(ILocalAutoRefreshCache localCache) =\u0026gt; this.localCache = localCache;\rpublic Configuration GetConfiguration()\r{\rvar cachedConfig = localCache.GetById\u0026lt;Configuration\u0026gt;(cacheKey);\rif (cachedConfig != null)\r{\rreturn cachedConfig;\r}\rlock (_lock)\r{\r// Check to see if anyone wrote in the cache while we're waiting for our turn\rcachedConfig = localCache.GetById\u0026lt;Configuration\u0026gt;(cacheKey);\rif (cachedConfig != null)\r{\rreturn cachedConfig;\r}\r// This method is not implemented because it can be anything. The main part is that you want to cache an object.\rcachedConfig = GetConfigurationFromRemoteLocation(provider);\rint refreshTimeInSeconds = 3600; // 1 hour\rlocalCache.Save(cacheKey, cachedConfig, GetPolicy(refreshTimeInSeconds));\rreturn cachedConfig;\r}\r}\rprivate CacheItemPolicy GetPolicy(int refreshInterval)\r{\rreturn new CacheItemPolicy\r{\r// This is where the magic happens\r// The UpdateCallback will be called before our object is removed from the cache\rUpdateCallback = (CacheEntryUpdateArguments args) =\u0026gt;\r{\rif (args.RemovedReason == CacheEntryRemovedReason.Expired)\r{\rvar cacheKey = args.Key;\r// Get current cached value\rvar currentCachedEntity = args.Source[cacheKey] as Configuration;\r// Get the potentially new data\rvar newEntity = GetConfigurationFromRemoteLocation(provider);\r// If new is not null - update, otherwise just refresh the old value\r// The condition by which you decide to update or refresh the data depends entirely on you\rif (newEntity != null)\r{\rvar updatedEntity = newEntity;\rargs.UpdatedCacheItem = new CacheItem(cacheKey, updatedEntity);\rargs.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);\r}\relse\r{\rvar updatedEntity = currentCachedEntity;\rargs.UpdatedCacheItem = new CacheItem(cacheKey, updatedEntity);\rargs.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);\r}\r}\r},\rAbsoluteExpiration = DateTime.UtcNow.AddSeconds(refreshInterval),\r};\r}\r}\r}\r So there you go! Now you can refresh, update or invalidate your cache every hour depending on the behavior you desire!\nBonus As a bonus you can read on the interesting thing that happens when you put AbsoluteExpiration below 20 seconds here.\nAlso it\u0026rsquo;s important to note that items can expire some time after the AbsoluteExpiration, there\u0026rsquo;s no guarantee that they\u0026rsquo;ll expire right on the spot. Here are two tests confirming that (I know we shouldn\u0026rsquo;t test code that isn\u0026rsquo;t ours, but it\u0026rsquo;s fun!)\nusing FooBar.Caching;\rusing NUnit.Framework;\rusing System;\rusing System.Runtime.Caching;\rusing System.Threading;\rusing System.Threading.Tasks;\rnamespace FooBar.Caching.UnitTests\r{\r[TestFixture]\rpublic class MemoryAutoRefreshCacheTests\r{\rprivate MemoryAutoRefreshCache subject;\rprivate int updateItemCounter = 0;\r[SetUp]\rpublic void Setup() =\u0026gt; subject = new MemoryAutoRefreshCache();\r[Test]\rpublic async Task VerifyUpdateCallback_LocalMemoryCache()\r{\rupdateItemCounter = 0;\rsubject.Save($\u0026quot;key\u0026quot;, \u0026quot;value\u0026quot;, GetPolicy(1));\r// The item can be expired between 0 and 30 seconds after expiration time\rawait Task.Delay(TimeSpan.FromSeconds(32));\r// Test that the update callback was invoked at least once\rAssert.IsTrue(updateItemCounter \u0026gt;= 1);\r}\r[Test]\rpublic void VerifyUpdateCallbackReturnsDuringRefresh_LocalMemoryCache()\r{\rupdateItemCounter = 0;\rstring key = \u0026quot;key\u0026quot;;\rstring value = \u0026quot;value\u0026quot;;\rsubject.Save(key, value, GetPolicyWithDelay(1));\r// The item can be expired between 0 and 30 seconds after expiration time\rvar start = DateTime.UtcNow;\rdo\r{\rvar cachedItem = subject.GetById\u0026lt;string\u0026gt;(\u0026quot;key\u0026quot;);\rAssert.AreEqual(value, cachedItem);\r} while (start.AddSeconds(40) \u0026gt; DateTime.UtcNow);\rAssert.IsTrue(updateItemCounter \u0026gt;= 1);\r}\rprivate string AddKeys(string key)\r{\rupdateItemCounter++;\rreturn key + key;\r}\rprivate void UpdateCounter()\r{\rupdateItemCounter++;\r}\rprivate CacheItemPolicy GetPolicyWithDelay(double refreshInterval)\r{\rreturn new CacheItemPolicy\r{\rUpdateCallback = (CacheEntryUpdateArguments args) =\u0026gt;\r{\rif (args.RemovedReason == CacheEntryRemovedReason.Expired)\r{\rThread.Sleep(2000);\rvar id = args.Key;\r// Get current cached value\rvar currentCachedEntity = args.Source[id] as string;\rUpdateCounter();\rvar newEntity = args.Source[id];\r// If new is not null - update, otherwise just refresh the old value\rif (newEntity != null)\r{\rvar updatedEntity = newEntity;\rargs.UpdatedCacheItem = new CacheItem(id, updatedEntity);\rargs.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);\r}\relse\r{\rvar updatedEntity = currentCachedEntity;\rargs.UpdatedCacheItem = new CacheItem(id, updatedEntity);\rargs.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);\r}\r}\r},\rAbsoluteExpiration = DateTimeOffset.UtcNow.AddSeconds(refreshInterval)\r};\r}\rprivate CacheItemPolicy GetPolicy(double refreshInterval)\r{\rreturn new CacheItemPolicy\r{\rUpdateCallback = (CacheEntryUpdateArguments args) =\u0026gt;\r{\rif (args.RemovedReason == CacheEntryRemovedReason.Expired)\r{\rvar id = args.Key;\r// Get current cached value\rvar currentCachedEntity = args.Source[id] as string;\rvar newEntity = AddKeys(id);\r// If new is not null - update, otherwise just refresh the old value\rif (newEntity != null)\r{\rvar updatedEntity = newEntity;\rargs.UpdatedCacheItem = new CacheItem(id, updatedEntity);\rargs.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);\r}\relse\r{\rvar updatedEntity = currentCachedEntity;\rargs.UpdatedCacheItem = new CacheItem(id, updatedEntity);\rargs.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);\r}\r}\r},\rSlidingExpiration = TimeSpan.FromSeconds(refreshInterval),\r};\r}\r}\r}\r Implementation with IMemoryCache in .NET Core I have a strong feeling a lot of people will come to read this article for the part that follows\u0026hellip; Who cares about .NET Framework, amirite?! It\u0026rsquo;s all about .NET Core nowadays, son!\nI\u0026rsquo;d be lying if I didn\u0026rsquo;t say that I prefer the .NET Core implementation. But I digress. Let\u0026rsquo;s stay on the issue at hand - implementing an auto refreshing cache.\nWe still have access to MemoryCache in .NET Core. However it only provides a callback which will execute after an item has been removed. That doesn\u0026rsquo;t matter for our use case. Remember what we said at the start. We don\u0026rsquo;t care if we get stale data as long as there are no cache misses! To achieve the same thing we did in the previous section we are going to use a shiny new interface called IMemoryCache. And guess what! It\u0026rsquo;s provided by Microsoft too!\nThe code is more or less the same with some differences when it comes to the locking. This time we\u0026rsquo;re performing operations inside an async method so we can\u0026rsquo;t use a regular lock. For the sake of completeness I\u0026rsquo;ll provide the full implementation + tests and gotchas after.\nusing System;\rusing System.Collections.Concurrent;\rusing System.Threading;\rusing System.Threading.Tasks;\rusing Microsoft.Extensions.Caching.Memory;\rnamespace FooBar.Providers\r{\rpublic class SettingsStore\r{\rprivate const string cacheKey = \u0026quot;FooBarPrivateKey\u0026quot;;\rprivate const int refreshTimeInSeconds = 3600;\rprivate readonly IMemoryCache memoryCache;\rprivate readonly ConcurrentDictionary\u0026lt;object, SemaphoreSlim\u0026gt; locks = new ConcurrentDictionary\u0026lt;object, SemaphoreSlim\u0026gt;();\rpublic SettingsStore(IMemoryCache memoryCache) =\u0026gt; this.memoryCache = memoryCache;\rpublic async Task\u0026lt;Settings\u0026gt; GetSettingsAsync()\r{\r// Normal lock doesn't work in async code\rif (!memoryCache.TryGetValue(cacheKey, out Settings settings))\r{\rSemaphoreSlim certLock = locks.GetOrAdd(cacheKey, k =\u0026gt; new SemaphoreSlim(1, 1));\rawait certLock.WaitAsync();\rtry\r{\rif (!memoryCache.TryGetValue(cacheKey, out settings))\r{\r// This method is not implemented because it can be anything.\r// The main part is that you want to cache an object.\rsettings = await GetSettingsFromRemoteLocation();\rmemoryCache.Set(cacheKey, settings, GetMemoryCacheEntryOptions(refreshTimeInSeconds)); // 1 hour\r}\r}\rfinally\r{\rcertLock.Release();\r}\r}\rreturn settings;\r}\rprivate MemoryCacheEntryOptions GetMemoryCacheEntryOptions(int expireInSeconds = 3600)\r{\rvar expirationTime = DateTime.Now.AddSeconds(expireInSeconds);\rvar expirationToken = new CancellationChangeToken(\rnew CancellationTokenSource(TimeSpan.FromSeconds(expireInSeconds + .01)).Token);\rvar options = new MemoryCacheEntryOptions();\roptions.SetAbsoluteExpiration(expirationTime);\roptions.AddExpirationToken(expirationToken);\roptions.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration()\r{\rEvictionCallback = (key, value, reason, state) =\u0026gt;\r{\rif (reason == EvictionReason.TokenExpired || reason == EvictionReason.Expired)\r{\r// If newValue is not null - update, otherwise just refresh the old value\r// The condition by which you decide to update or refresh the data depends entirely on you\r// If you want a cache object that will never expire you can just make the following call:\r// memoryCache.Set(key, value, GetMemoryCacheEntryOptions(expireInSeconds));\rvar newValue = await GetSettingsFromRemoteLocation();\rif (newValue != null)\r{\rmemoryCache.Set(key, newValue, GetMemoryCacheEntryOptions(expireInSeconds)); // 1 hour\r}\relse\r{\rmemoryCache.Set(key, value, GetMemoryCacheEntryOptions(expireInSeconds)); // 1 hour\r}\r}\r}\r});\rreturn options;\r}\r}\r}\r Here we have 2 interesting behaviors we should take into consideration. Why do we need to use a cancellation token, and why won\u0026rsquo;t the EvictionCallback execute after 1 hour without explicitly setting said token.\n  No background thread that actively scans the expiration. This means we have to trigger the eviction/expiration ourselves.\n  We can trigger an expiration with the help of a CancellationToken\n  To prove this to you I\u0026rsquo;ll provide another pair of tests\nusing System;\rusing System.Threading;\rusing System.Threading.Tasks;\rusing Microsoft.Extensions.Caching.Memory;\rusing Microsoft.Extensions.Primitives;\rusing Microsoft.VisualStudio.TestTools.UnitTesting;\rnamespace FooBar.Tests\r{\r[TestClass]\rpublic class MemoryCacheTests\r{\rprivate IMemoryCache CreateCache()\r{\rreturn new MemoryCache(new MemoryCacheOptions()\r{\rExpirationScanFrequency = new TimeSpan(0, 0, 1)\r});\r}\r[TestMethod]\rpublic async Task ExpireAndReAddFromCallbackWorks()\r{\rvar cache = CreateCache();\rvar initialValue = \u0026quot;I'm a value\u0026quot;;\rvar newValue = \u0026quot;I'm the refreshed value\u0026quot;;\rstring key = \u0026quot;myKey\u0026quot;;\rint refreshCounter = 0;\rvar options = new MemoryCacheEntryOptions();\roptions.SetAbsoluteExpiration(new TimeSpan(0, 0, 1));\roptions.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration()\r{\rEvictionCallback = (subkey, subValue, reason, state) =\u0026gt;\r{\rif (reason == EvictionReason.Expired)\r{\rcache.Set(key, newValue);\rrefreshCounter++;\r}\r}\r});\rcache.Set(key, initialValue, options);\rawait Task.Delay(TimeSpan.FromSeconds(6));\r// Any activity on the cache (Get, Set, Remove) can trigger a background scan for expired items.\r// There's no background thread that scans the cache for expired times\rvar result = cache.Get(key);\rawait Task.Delay(TimeSpan.FromSeconds(1));\rAssert.IsTrue(refreshCounter \u0026gt;= 1);\rAssert.AreEqual(newValue, cache.Get(key));\r}\r[TestMethod]\rpublic async Task TokenExpireAndReAddFromCallbackWorks()\r{\rvar cache = CreateCache();\rvar initialValue = \u0026quot;I'm a value\u0026quot;;\rvar newValue = \u0026quot;I'm the refreshed value\u0026quot;;\rstring key = \u0026quot;myKey\u0026quot;;\rint refreshCounter = 0;\rint expirationSeconds = 1;\rvar expirationTime = DateTime.Now.AddSeconds(expirationSeconds);\rvar expirationToken = new CancellationChangeToken(\rnew CancellationTokenSource(TimeSpan.FromSeconds(expirationSeconds + .01)).Token);\rvar options = new MemoryCacheEntryOptions();\roptions.SetAbsoluteExpiration(expirationTime);\roptions.AddExpirationToken(expirationToken);\roptions.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration()\r{\rEvictionCallback = (subkey, subValue, reason, state) =\u0026gt;\r{\rif (reason == EvictionReason.TokenExpired)\r{\rcache.Set(key, newValue);\rrefreshCounter++;\r}\r}\r});\rcache.Set(key, initialValue, options);\rawait Task.Delay(TimeSpan.FromSeconds(6));\rAssert.IsTrue(refreshCounter \u0026gt;= 1);\rAssert.AreEqual(newValue, cache.Get(key));\r}\r}\r}\r So that\u0026rsquo;s basically it! Now we have our auto refreshing cache! There\u0026rsquo;s a lot that we can improve. You have to be careful who has access to the keys for your specific object and a million other considerations. Caching is a steep hill to climb, but I hope you found this blog post informative in some capacity!\nI\u0026rsquo;ve used both implementations for some heavy objects that don\u0026rsquo;t change often in production environments and they\u0026rsquo;ve been doing their job pretty well so far!\n","permalink":"https://underscorehao.net/2019/07/auto-refreshing-cache-in-dotnet/","title":"Auto Refreshing Cache in .NET"},{"content":"The Problem Today I faced a problem which I knew would come, but didn\u0026rsquo;t have time to implement properly at the time. There were more urgent tasks at hand before, deadlines to be met and this issue remained unresolved.\nAmazon\u0026rsquo;s .NET Core SDK is very good for the most part. Everything works as it should. But let\u0026rsquo;s say you use the .NET Object Persistence Model for DynamoDB in your service and you have mapped C# classes to DynamoDB tables like this:\nnamespace Models\r{\r[DynamoDBTable(\u0026quot;Player\u0026quot;)]\rpublic class Player\r{\r[DynamoDBHashKey]\rpublic int Id { get; set; }\r[DynamoDBProperty]\rpublic string Name { get; set; }\r[DynamoDBProperty]\rpublic int HitPoints { get; set; }\r[DynamoDBProperty]\rpublic int Gold { get; set; }\r[DynamoDBProperty]\rpublic int Level { get; set; }\r[DynamoDBProperty]\rpublic List\u0026lt;string\u0026gt; Items { get; set; }\r}\r[DynamoDBTable(\u0026quot;Location\u0026quot;)]\rpublic class Location\r{\r[DynamoDBHashKey]\rpublic int Id { get; set; }\r[DynamoDBProperty]\rpublic string Name { get; set; }\r[DynamoDBProperty]\rpublic string Description { get; set; }\r}\r}\r It works well. Everything is mapped as it should. You have a service that calls the .NET SDK so you can write, read and delete data from the context like this:\nnamespace Services\r{\rpublic class DynamoDbService\r{\rpublic async Task\u0026lt;T\u0026gt; GetAsync\u0026lt;T\u0026gt;(string id)\r{\rtry\r{\rDynamoDBContext context = new DynamoDBContext(_dynamoDbClient);\rreturn await context.LoadAsync\u0026lt;T\u0026gt;(id);\r}\rcatch (Exception ex)\r{\rthrow new Exception($\u0026quot;Amazon error in Get operation! Error: {ex}\u0026quot;);\r}\r}\rpublic async Task WriteAsync\u0026lt;T\u0026gt;(T item)\r{\rtry\r{\rDynamoDBContext context = new DynamoDBContext(_dynamoDbClient);\rawait context.SaveAsync(item);\r}\rcatch (Exception ex)\r{\rthrow new Exception($\u0026quot;Amazon error in Write operation! Error: {ex}\u0026quot;);\r}\r}\rpublic async Task DeleteAsync\u0026lt;T\u0026gt;(T item)\r{\rtry\r{\rDynamoDBContext context = new DynamoDBContext(_dynamoDbClient);\rawait context.DeleteAsync(item)\r}\rcatch (Exception ex)\r{\rthrow new Exception($\u0026quot;Amazon error in Delete operation! Error: {ex}\u0026quot;);\r}\r}\r}\r}\r It\u0026rsquo;s all fun and games until you have to use different databases for different environments! Of course you can use the Document Model, but then you lose the nice mapping to C# classes and have to work with generic documents.\nC# attributes are not meant to change at runtime, so we\u0026rsquo;re in a tough spot! What can we do to tell our build pipeline which tables we\u0026rsquo;d like to use?\nThe Solution .NET Core\u0026rsquo;s powerful dependency injection comes to our rescue! First we create the same section (with the respective databases for our environments) in our appsettings.Development.json\n\u0026quot;DynamoDbTables\u0026quot;: {\r\u0026quot;Player\u0026quot;: \u0026quot;DevPlayer\u0026quot;,\r\u0026quot;Location\u0026quot;: \u0026quot;DevLocation\u0026quot;\r}\r and appsettings.json file\n\u0026quot;DynamoDbTables\u0026quot;: {\r\u0026quot;Player\u0026quot;: \u0026quot;ProdPlayer\u0026quot;,\r\u0026quot;Location\u0026quot;: \u0026quot;ProdLocation\u0026quot;\r}\r Then we head up and create a simple configuration class which we\u0026rsquo;ll bind to our DynamoDbTables JSON object later\npublic class DynamoDbOptions\r{\rpublic string Player { get; set; }\rpublic string Location { get; set; }\r}\r After that we have to create our custom DynamoDb context interface\npublic interface IDynamoDbContext\u0026lt;T\u0026gt; : IDisposable where T : class\r{\rTask\u0026lt;T\u0026gt; GetByIdAsync(string id);\rTask SaveAsync(T item);\rTask DeleteByIdAsync(T item);\r}\r and the context class which we\u0026rsquo;ll inject in our services\npublic class DynamoDbContext\u0026lt;T\u0026gt; : DynamoDBContext, IDynamoDbContext\u0026lt;T\u0026gt;\rwhere T : class\r{\rprivate DynamoDBOperationConfig _config;\rpublic DynamoDbContext(IAmazonDynamoDB client, string tableName)\r: base(client)\r{\r_config = new DynamoDBOperationConfig()\r{\rOverrideTableName = tableName\r};\r}\rpublic async Task\u0026lt;T\u0026gt; GetByIdAsync(string id)\r{\rreturn await base.LoadAsync\u0026lt;T\u0026gt;(id, _config);\r}\rpublic async Task SaveAsync(T item)\r{\rawait base.SaveAsync(item, _config);\r}\rpublic async Task DeleteByIdAsync(T item)\r{\rawait base.DeleteAsync(item, _config);\r}\r}\r Then we go to our Startup.cs and add a couple of lines to our ConfigureServices() method\n// AWS Options\rvar awsOptions = Configuration.GetAWSOptions();\rservices.AddDefaultAWSOptions(awsOptions);\rvar client = awsOptions.CreateServiceClient\u0026lt;IAmazonDynamoDB\u0026gt;();\rvar dynamoDbOptions = new DynamoDbOptions();\rConfigurationBinder.Bind(Configuration.GetSection(\u0026quot;DynamoDbTables\u0026quot;), dynamoDbOptions);\r// This is where the magic happens\rservices.AddScoped\u0026lt;IDynamoDbContext\u0026lt;Player\u0026gt;\u0026gt;(provider =\u0026gt; new DynamoDbContext\u0026lt;Player\u0026gt;(client, dynamoDbOptions.Player));\rservices.AddScoped\u0026lt;IDynamoDbContext\u0026lt;Location\u0026gt;\u0026gt;(provider =\u0026gt; new DynamoDbContext\u0026lt;Location\u0026gt;(client, dynamoDbOptions.Location));\r And voilà! We can now remove the [DynamoDBTable(\u0026quot;SomeTableName\u0026quot;)] attributes from our classes. We can keep both [DynamoDBHashKey] and [DynamoDBProperty] attributes. If we need custom converters we can just add [DynamoDBProperty(typeof(SomeConverter))] attribute to our property.\n// No table name attribute needed!\rpublic class Player\r{\r[DynamoDBHashKey]\rpublic int Id { get; set; }\r[DynamoDBProperty]\rpublic string Name { get; set; }\r[DynamoDBProperty]\rpublic int HitPoints { get; set; }\r[DynamoDBProperty]\rpublic int Gold { get; set; }\r[DynamoDBProperty]\rpublic int Level { get; set; }\r[DynamoDBProperty]\rpublic List\u0026lt;string\u0026gt; Items { get; set; }\r}\r// No table name attribute needed!\rpublic class Location\r{\r[DynamoDBHashKey]\rpublic int Id { get; set; }\r[DynamoDBProperty]\rpublic string Name { get; set; }\r[DynamoDBProperty]\rpublic string Description { get; set; }\r}\r and we can use the desired context with their respective tables in our services!\nnamespace Services\r{\rpublic class AwesomeDynamoDbService\r{\rprivate IDynamoDbContext\u0026lt;Player\u0026gt; _playerContext;\rprivate IDynamoDbContext\u0026lt;Location\u0026gt; _locationContext;\rpublic AwesomeDynamoDbService(IDynamoDbContext\u0026lt;Player\u0026gt; playerContext, IDynamoDbContext\u0026lt;Location\u0026gt; locationContext)\r{\r_playerContext = playerContext;\r_locationContext = locationContext;\r}\rpublic async Task\u0026lt;User\u0026gt; GetUserAsync(string id)\r{\rtry\r{\rreturn await _playerContext.GetByIdAsync(id);\r}\rcatch (Exception ex)\r{\rthrow new Exception($\u0026quot;Amazon error in GetUser table operation! Error: {ex}\u0026quot;);\r}\r}\rpublic async Task\u0026lt;Location\u0026gt; GetLocationAsync(string id)\r{\rtry\r{\rreturn await _locationContext.GetByIdAsync(id);\r}\rcatch (Exception ex)\r{\rthrow new Exception($\u0026quot;Amazon error in GetLocation table operation! Error: {ex}\u0026quot;);\r}\r}\r}\r}\r Depending on your case you can use different services for different tables or other requirements. This solution might seem a bit more cumbersome than the original, but it makes us flexible in case we need to work with multiple databases and different build environments. The only thing you have to do is to tell your build tool/pipeline to change the table names in your appsettings.json files.\nThis method also is more robust when it comes to testing because it\u0026rsquo;ll be much easier to mock! All in all I\u0026rsquo;m really happy with how it all turned out!\n","permalink":"https://underscorehao.net/2018/03/net-core-api-dynamodb-dependency-injection/","title":".NET Core API with DynamoDB Context Dependency Injection"}]