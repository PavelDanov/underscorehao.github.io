<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">
    <meta name="color-scheme" content="light dark">

    

    <meta name="author" content="Pavel Danov">
    <meta name="description" content="Caching is hardOn a bright sunny day while you&rsquo;re working on your awesome project you catch a glimpse of something. You bring yourself closer to the monitor and begin meticulously examining your code. What you find brings you feelings of disgust and shame! You&rsquo;ve been calling an API retrieving data you need over and over again even though said data hardly changes!
Being the smart and responsible engineer that you are, you decide to rectify your mistake immediately.">
    <meta name="keywords" content="blog,developer,personal,back-end,c#,c&#43;&#43;,.net,dotnet,programming,software,tech,backend,fintech,gamedev,games,martial arts,books">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Auto Refreshing Cache in .NET"/>
<meta name="twitter:description" content="Caching is hardOn a bright sunny day while you&rsquo;re working on your awesome project you catch a glimpse of something. You bring yourself closer to the monitor and begin meticulously examining your code. What you find brings you feelings of disgust and shame! You&rsquo;ve been calling an API retrieving data you need over and over again even though said data hardly changes!
Being the smart and responsible engineer that you are, you decide to rectify your mistake immediately."/>

    <meta property="og:title" content="Auto Refreshing Cache in .NET" />
<meta property="og:description" content="Caching is hardOn a bright sunny day while you&rsquo;re working on your awesome project you catch a glimpse of something. You bring yourself closer to the monitor and begin meticulously examining your code. What you find brings you feelings of disgust and shame! You&rsquo;ve been calling an API retrieving data you need over and over again even though said data hardly changes!
Being the smart and responsible engineer that you are, you decide to rectify your mistake immediately." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://underscorehao.net/2019/07/auto-refreshing-cache-in-dotnet/" />
<meta property="article:published_time" content="2019-07-11T22:47:02+01:00" />
<meta property="article:modified_time" content="2019-07-11T22:47:02+01:00" />


    <title>
  Auto Refreshing Cache in .NET Â· _hao
</title>

    
      <link rel="canonical" href="https://underscorehao.net/2019/07/auto-refreshing-cache-in-dotnet/">
    

    <link rel="preload" href="https://underscorehao.net/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="https://underscorehao.net/css/coder.min.d9fddbffe6f27e69985dc5fe0471cdb0e57fbf4775714bc3d847accb08f4a1f6.css" integrity="sha256-2f3b/&#43;byfmmYXcX&#43;BHHNsOV/v0d1cUvD2Eesywj0ofY=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="https://underscorehao.net/css/coder-dark.min.002ee2378e14c7a68f1f0a53d9694ed252090987c4e768023fac694a4fc5f793.css" integrity="sha256-AC7iN44Ux6aPHwpT2WlO0lIJCYfE52gCP6xpSk/F95M=" crossorigin="anonymous" media="screen" />
      
    

    

    

    <link rel="icon" type="image/png" href="https://underscorehao.net/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://underscorehao.net/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="https://underscorehao.net/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://underscorehao.net/images/apple-touch-icon.png">

    <meta name="generator" content="Hugo 0.80.0" />
  </head>

  
  
    
  
  <body class="preload-transitions colorscheme-dark">
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://underscorehao.net/">
      _hao
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://underscorehao.net/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://underscorehao.net/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://underscorehao.net/2021-book-list/">2021 Book List</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://underscorehao.net/contact/">Contact</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://underscorehao.net/2019/07/auto-refreshing-cache-in-dotnet/">
              Auto Refreshing Cache in .NET
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2019-07-11T22:47:02&#43;01:00'>
                July 11, 2019
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              10-minute read
            </span>
          </div>
          
          
          
        </div>
      </header>

      <div>
        
		
        <h2 id="caching-is-hard">
  Caching is hard
  <a class="heading-link" href="#caching-is-hard">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>On a bright sunny day while you&rsquo;re working on your awesome project you catch a glimpse of something. You bring yourself closer to the monitor and begin meticulously examining your code. What you find brings you feelings of disgust and shame! You&rsquo;ve been calling an API retrieving data you need over and over again even though said data hardly changes!</p>
<p>Being the smart and responsible engineer that you are, you decide to rectify your mistake immediately. You think to yourself</p>
<blockquote>
<p>&ldquo;OK, I&rsquo;ll just implement caching around that piece of data and I&rsquo;m done!&rdquo;</p>
</blockquote>
<p>Not so fast! Little do you know that you&rsquo;re opening the gates of your own small personal hell!</p>
<h2 id="caching-in-net">
  Caching in .NET
  <a class="heading-link" href="#caching-in-net">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>The little story above is a <em>slight</em> exaggeration, but caching is indeed a touchy subject. It&rsquo;s a nice performance boost when done right, but it can also lead you to a dark path filled with scary monsters and unforeseen problems.</p>
<p>There are many articles written on caching in .NET, you should read the official docs and perhaps other articles written by the good people on the Internet.</p>
<p>This article however will deal with a very specific caching problem. How can you implement a cache that is refreshing itself after a specific amount of time with the following characteristics:</p>
<ul>
<li>Thread safety</li>
<li>Not getting any cache misses (even if that means we&rsquo;re returning stale data)</li>
</ul>
<p>If that&rsquo;s what you need, keep on reading!</p>
<h2 id="implementation-with-memorycache-in-net-framework">
  Implementation with MemoryCache in .NET Framework
  <a class="heading-link" href="#implementation-with-memorycache-in-net-framework">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>Let&rsquo;s start with the simple stuff. We want to perform some basic CRUD operations on our cache - saving data to it, getting our cached objects and potentially deleting our data. The best way to do it is to define an interface.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System.Runtime.Caching;

<span style="color:#66d9ef">namespace</span> FooBar.Caching
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> IMemoryAutoRefreshCache
    {
        T GetById&lt;T&gt;(<span style="color:#66d9ef">string</span> id);
        <span style="color:#66d9ef">void</span> Save&lt;T&gt;(<span style="color:#66d9ef">string</span> id, T cacheObj, CacheItemPolicy refreshPolicy);
        <span style="color:#66d9ef">void</span> Remove(<span style="color:#66d9ef">string</span> id);
    }
}
</code></pre></div><p>These are the methods I&rsquo;m going to use to illustrate my example. Depending on your use case you can have a lot more of them doing various things to your cache, but for my case those are enough. The point I want you to focus on here is the <strong><code>CacheItemPolicy</code></strong> we can set during the Save.</p>
<p>Now that we have our interface we can also implement it in a new class</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System.Runtime.Caching;

<span style="color:#66d9ef">namespace</span> FooBar.Caching
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MemoryAutoRefreshCache</span> : IMemoryAutoRefreshCache
    {
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> MemoryCache memoryCache;

        <span style="color:#66d9ef">public</span> MemoryAutoRefreshCache(MemoryCache memoryCache = <span style="color:#66d9ef">null</span>) =&gt; <span style="color:#66d9ef">this</span>.memoryCache = memoryCache ?? MemoryCache.Default;

        <span style="color:#66d9ef">public</span> T GetById&lt;T&gt;(<span style="color:#66d9ef">string</span> id)
        {
            <span style="color:#66d9ef">var</span> <span style="color:#66d9ef">value</span> = (T)memoryCache.Get(id);
            <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">value</span> == <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">default</span>(T);
            }

            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">value</span>;
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Save&lt;T&gt;(<span style="color:#66d9ef">string</span> id, T result, CacheItemPolicy refreshPolicy)
        {
            memoryCache.Set(id, result, refreshPolicy);
        }

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Remove(<span style="color:#66d9ef">string</span> id)
        {
            memoryCache.Remove(id);
        }
    }
}
</code></pre></div><p>Nothing out of the ordinary here. I want to bring your attention to our <strong><code>Save</code></strong> method one more time and the CacheItemPolicy. The summary of <strong><code>CacheItemPolicy</code></strong> states:</p>
<blockquote>
<p>Represents a set of eviction and expiration details for a specific cache entry.</p>
</blockquote>
<p>Inside the <strong><code>CacheItemPolicy</code></strong> we have two callbacks which will give us everything we need to accomplish our task.</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.caching.cacheentryremovedcallback?view=netframework-4.8"><strong><code>RemovedCallback</code></strong></a> - Occurs <strong><em>after</em></strong> the item has been removed</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.caching.cacheentryupdatecallback?view=netframework-4.8"><strong><code>UpdateCallback</code></strong></a> - Occurs <strong><em>before</em></strong> the item is removed</li>
</ul>
<p>As you can imagine we&rsquo;ll use the <strong><code>UpdateCallback</code></strong> in our case.</p>
<p>So let&rsquo;s see how an implementation of this auto refreshing cache will look like!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Runtime.Caching;
<span style="color:#66d9ef">using</span> System.Threading;
<span style="color:#66d9ef">using</span> FooBar.Caching;

<span style="color:#66d9ef">namespace</span> FooBar.Services.Configuration
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConfigurationProvider</span>
    {
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IMemoryAutoRefreshCache localCache;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">string</span> cacheKey = <span style="color:#e6db74">&#34;myAwesomeCacheKey&#34;</span>;

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">object</span> _lock = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">object</span>();

        <span style="color:#66d9ef">public</span> ConfigurationProvider(ILocalAutoRefreshCache localCache) =&gt; <span style="color:#66d9ef">this</span>.localCache = localCache;

        <span style="color:#66d9ef">public</span> Configuration GetConfiguration()
        {
            <span style="color:#66d9ef">var</span> cachedConfig = localCache.GetById&lt;Configuration&gt;(cacheKey);
            <span style="color:#66d9ef">if</span> (cachedConfig != <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">return</span> cachedConfig;
            }

            <span style="color:#66d9ef">lock</span> (_lock)
            {
                <span style="color:#75715e">// Check to see if anyone wrote in the cache while we&#39;re waiting for our turn
</span><span style="color:#75715e"></span>                cachedConfig = localCache.GetById&lt;Configuration&gt;(cacheKey);
                <span style="color:#66d9ef">if</span> (cachedConfig != <span style="color:#66d9ef">null</span>)
                {
                    <span style="color:#66d9ef">return</span> cachedConfig;
                }

                <span style="color:#75715e">// This method is not implemented because it can be anything. The main part is that you want to cache an object.
</span><span style="color:#75715e"></span>                cachedConfig = GetConfigurationFromRemoteLocation(provider);
                <span style="color:#66d9ef">int</span> refreshTimeInSeconds = <span style="color:#ae81ff">3600</span>; <span style="color:#75715e">// 1 hour
</span><span style="color:#75715e"></span>                localCache.Save(cacheKey, cachedConfig, GetPolicy(refreshTimeInSeconds));

                <span style="color:#66d9ef">return</span> cachedConfig;
            }
        }

        <span style="color:#66d9ef">private</span> CacheItemPolicy GetPolicy(<span style="color:#66d9ef">int</span> refreshInterval)
        {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> CacheItemPolicy
            {
                <span style="color:#75715e">// This is where the magic happens
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// The UpdateCallback will be called before our object is removed from the cache
</span><span style="color:#75715e"></span>                UpdateCallback = (CacheEntryUpdateArguments args) =&gt;
                {
                    <span style="color:#66d9ef">if</span> (args.RemovedReason == CacheEntryRemovedReason.Expired)
                    {
                        <span style="color:#66d9ef">var</span> cacheKey = args.Key;

                        <span style="color:#75715e">// Get current cached value
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">var</span> currentCachedEntity = args.Source[cacheKey] <span style="color:#66d9ef">as</span> Configuration;

                        <span style="color:#75715e">// Get the potentially new data
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">var</span> newEntity = GetConfigurationFromRemoteLocation(provider);

                        <span style="color:#75715e">// If new is not null - update, otherwise just refresh the old value
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// The condition by which you decide to update or refresh the data depends entirely on you
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (newEntity != <span style="color:#66d9ef">null</span>)
                        {
                            <span style="color:#66d9ef">var</span> updatedEntity = newEntity;
                            args.UpdatedCacheItem = <span style="color:#66d9ef">new</span> CacheItem(cacheKey, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                        <span style="color:#66d9ef">else</span>
                        {
                            <span style="color:#66d9ef">var</span> updatedEntity = currentCachedEntity;
                            args.UpdatedCacheItem = <span style="color:#66d9ef">new</span> CacheItem(cacheKey, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                    }
                },
                AbsoluteExpiration = DateTime.UtcNow.AddSeconds(refreshInterval),
            };
        }
    }
}
</code></pre></div><p>So there you go! Now you can refresh, update or invalidate your cache every hour depending on the behavior you desire!</p>
<h3 id="bonus">
  Bonus
  <a class="heading-link" href="#bonus">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>As a bonus you can read on the interesting thing that happens when you put <strong><code>AbsoluteExpiration</code></strong> below 20 seconds <a href="https://stackoverflow.com/questions/12630168/memorycache-absoluteexpiration-acting-strange">here</a>.</p>
<p>Also it&rsquo;s important to note that items can expire some time after the AbsoluteExpiration, there&rsquo;s no guarantee that they&rsquo;ll expire right on the spot. Here are two tests confirming that (I know we shouldn&rsquo;t test code that isn&rsquo;t ours, but it&rsquo;s fun!)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> FooBar.Caching;
<span style="color:#66d9ef">using</span> NUnit.Framework;
<span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Runtime.Caching;
<span style="color:#66d9ef">using</span> System.Threading;
<span style="color:#66d9ef">using</span> System.Threading.Tasks;

<span style="color:#66d9ef">namespace</span> FooBar.Caching.UnitTests
{
<span style="color:#a6e22e">    [TestFixture]</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MemoryAutoRefreshCacheTests</span>
    {
        <span style="color:#66d9ef">private</span> MemoryAutoRefreshCache subject;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> updateItemCounter = <span style="color:#ae81ff">0</span>;
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [SetUp]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Setup() =&gt; subject = <span style="color:#66d9ef">new</span> MemoryAutoRefreshCache();
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [Test]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task VerifyUpdateCallback_LocalMemoryCache()
        {
            updateItemCounter = <span style="color:#ae81ff">0</span>;

            subject.Save(<span style="color:#e6db74">$&#34;key&#34;</span>, <span style="color:#e6db74">&#34;value&#34;</span>, GetPolicy(<span style="color:#ae81ff">1</span>));

            <span style="color:#75715e">// The item can be expired between 0 and 30 seconds after expiration time
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">await</span> Task.Delay(TimeSpan.FromSeconds(<span style="color:#ae81ff">32</span>));

            <span style="color:#75715e">// Test that the update callback was invoked at least once
</span><span style="color:#75715e"></span>            Assert.IsTrue(updateItemCounter &gt;= <span style="color:#ae81ff">1</span>);
        }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [Test]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> VerifyUpdateCallbackReturnsDuringRefresh_LocalMemoryCache()
        {
            updateItemCounter = <span style="color:#ae81ff">0</span>;

            <span style="color:#66d9ef">string</span> key = <span style="color:#e6db74">&#34;key&#34;</span>;
            <span style="color:#66d9ef">string</span> <span style="color:#66d9ef">value</span> = <span style="color:#e6db74">&#34;value&#34;</span>;

            subject.Save(key, <span style="color:#66d9ef">value</span>, GetPolicyWithDelay(<span style="color:#ae81ff">1</span>));

            <span style="color:#75715e">// The item can be expired between 0 and 30 seconds after expiration time
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">var</span> start = DateTime.UtcNow;

            <span style="color:#66d9ef">do</span>
            {
                <span style="color:#66d9ef">var</span> cachedItem = subject.GetById&lt;<span style="color:#66d9ef">string</span>&gt;(<span style="color:#e6db74">&#34;key&#34;</span>);
                Assert.AreEqual(<span style="color:#66d9ef">value</span>, cachedItem);
            } <span style="color:#66d9ef">while</span> (start.AddSeconds(<span style="color:#ae81ff">40</span>) &gt; DateTime.UtcNow);

            Assert.IsTrue(updateItemCounter &gt;= <span style="color:#ae81ff">1</span>);
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> AddKeys(<span style="color:#66d9ef">string</span> key)
        {
            updateItemCounter++;
            <span style="color:#66d9ef">return</span> key + key;
        }

        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> UpdateCounter()
        {
            updateItemCounter++;
        }

        <span style="color:#66d9ef">private</span> CacheItemPolicy GetPolicyWithDelay(<span style="color:#66d9ef">double</span> refreshInterval)
        {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> CacheItemPolicy
            {
                UpdateCallback = (CacheEntryUpdateArguments args) =&gt;
                {
                    <span style="color:#66d9ef">if</span> (args.RemovedReason == CacheEntryRemovedReason.Expired)
                    {
                        Thread.Sleep(<span style="color:#ae81ff">2000</span>);
                        <span style="color:#66d9ef">var</span> id = args.Key;

                        <span style="color:#75715e">// Get current cached value
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">var</span> currentCachedEntity = args.Source[id] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">string</span>;
                        UpdateCounter();

                        <span style="color:#66d9ef">var</span> newEntity = args.Source[id];

                        <span style="color:#75715e">// If new is not null - update, otherwise just refresh the old value
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (newEntity != <span style="color:#66d9ef">null</span>)
                        {
                            <span style="color:#66d9ef">var</span> updatedEntity = newEntity;
                            args.UpdatedCacheItem = <span style="color:#66d9ef">new</span> CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                        <span style="color:#66d9ef">else</span>
                        {
                            <span style="color:#66d9ef">var</span> updatedEntity = currentCachedEntity;
                            args.UpdatedCacheItem = <span style="color:#66d9ef">new</span> CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }

                    }
                },
                AbsoluteExpiration = DateTimeOffset.UtcNow.AddSeconds(refreshInterval)
            };
        }

        <span style="color:#66d9ef">private</span> CacheItemPolicy GetPolicy(<span style="color:#66d9ef">double</span> refreshInterval)
        {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> CacheItemPolicy
            {
                UpdateCallback = (CacheEntryUpdateArguments args) =&gt;
                {
                    <span style="color:#66d9ef">if</span> (args.RemovedReason == CacheEntryRemovedReason.Expired)
                    {
                        <span style="color:#66d9ef">var</span> id = args.Key;

                        <span style="color:#75715e">// Get current cached value
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">var</span> currentCachedEntity = args.Source[id] <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">string</span>;

                        <span style="color:#66d9ef">var</span> newEntity = AddKeys(id);

                        <span style="color:#75715e">// If new is not null - update, otherwise just refresh the old value
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (newEntity != <span style="color:#66d9ef">null</span>)
                        {
                            <span style="color:#66d9ef">var</span> updatedEntity = newEntity;
                            args.UpdatedCacheItem = <span style="color:#66d9ef">new</span> CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                        <span style="color:#66d9ef">else</span>
                        {
                            <span style="color:#66d9ef">var</span> updatedEntity = currentCachedEntity;
                            args.UpdatedCacheItem = <span style="color:#66d9ef">new</span> CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }

                    }
                },
                SlidingExpiration = TimeSpan.FromSeconds(refreshInterval),
            };
        }
    }
}
</code></pre></div><h2 id="implementation-with-imemorycache-in-net-core">
  Implementation with IMemoryCache in .NET Core
  <a class="heading-link" href="#implementation-with-imemorycache-in-net-core">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>I have a strong feeling a lot of people will come to read this article for the part that follows&hellip; Who cares about .NET Framework, amirite?! It&rsquo;s all about .NET Core nowadays, son!</p>
<p>I&rsquo;d be lying if I didn&rsquo;t say that I prefer the .NET Core implementation. But I digress. Let&rsquo;s stay on the issue at hand - implementing an auto refreshing cache.</p>
<p>We still have access to <strong><code>MemoryCache</code>** in .NET Core. However it only provides a callback which will execute <strong>_after_** an item has been <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.postevictioncallbacks?view=aspnetcore-2.2#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_PostEvictionCallbacks">removed</a>. That doesn&rsquo;t matter for our use case. Remember what we said at the start. We don&rsquo;t care if we get stale data as long as there are no cache misses! To achieve the same thing we did in the previous section we are going to use a shiny new interface called </strong><code>IMemoryCache</code></strong><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.imemorycache?view=aspnetcore-2.2"></a>. And guess what! It&rsquo;s provided by Microsoft too!</p>
<p>The code is more or less the same with some differences when it comes to the locking. This time we&rsquo;re performing operations inside an async method so we can&rsquo;t use a regular lock. For the sake of completeness I&rsquo;ll provide the full implementation + tests and gotchas after.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Collections.Concurrent;
<span style="color:#66d9ef">using</span> System.Threading;
<span style="color:#66d9ef">using</span> System.Threading.Tasks;
<span style="color:#66d9ef">using</span> Microsoft.Extensions.Caching.Memory;

<span style="color:#66d9ef">namespace</span> FooBar.Providers
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SettingsStore</span>
    {
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">string</span> cacheKey = <span style="color:#e6db74">&#34;FooBarPrivateKey&#34;</span>;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> refreshTimeInSeconds = <span style="color:#ae81ff">3600</span>;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IMemoryCache memoryCache;
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ConcurrentDictionary&lt;<span style="color:#66d9ef">object</span>, SemaphoreSlim&gt; locks = <span style="color:#66d9ef">new</span> ConcurrentDictionary&lt;<span style="color:#66d9ef">object</span>, SemaphoreSlim&gt;();

        <span style="color:#66d9ef">public</span> SettingsStore(IMemoryCache memoryCache) =&gt; <span style="color:#66d9ef">this</span>.memoryCache = memoryCache;

        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task&lt;Settings&gt; GetSettingsAsync()
        {
            <span style="color:#75715e">// Normal lock doesn&#39;t work in async code
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (!memoryCache.TryGetValue(cacheKey, <span style="color:#66d9ef">out</span> Settings settings))
            {
                SemaphoreSlim certLock = locks.GetOrAdd(cacheKey, k =&gt; <span style="color:#66d9ef">new</span> SemaphoreSlim(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>));
                <span style="color:#66d9ef">await</span> certLock.WaitAsync();

                <span style="color:#66d9ef">try</span>
                {
                    <span style="color:#66d9ef">if</span> (!memoryCache.TryGetValue(cacheKey, <span style="color:#66d9ef">out</span> settings))
                    {
                        <span style="color:#75715e">// This method is not implemented because it can be anything.
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// The main part is that you want to cache an object.
</span><span style="color:#75715e"></span>                        settings = <span style="color:#66d9ef">await</span> GetSettingsFromRemoteLocation();
                        memoryCache.Set(cacheKey, settings, GetMemoryCacheEntryOptions(refreshTimeInSeconds)); <span style="color:#75715e">// 1 hour
</span><span style="color:#75715e"></span>                    }
                }
                <span style="color:#66d9ef">finally</span>
                {
                    certLock.Release();
                }
            }
            <span style="color:#66d9ef">return</span> settings;
        }

        <span style="color:#66d9ef">private</span> MemoryCacheEntryOptions GetMemoryCacheEntryOptions(<span style="color:#66d9ef">int</span> expireInSeconds = <span style="color:#ae81ff">3600</span>)
        {
            <span style="color:#66d9ef">var</span> expirationTime = DateTime.Now.AddSeconds(expireInSeconds);
            <span style="color:#66d9ef">var</span> expirationToken = <span style="color:#66d9ef">new</span> CancellationChangeToken(
                <span style="color:#66d9ef">new</span> CancellationTokenSource(TimeSpan.FromSeconds(expireInSeconds + .<span style="color:#ae81ff">01</span>)).Token);

            <span style="color:#66d9ef">var</span> options = <span style="color:#66d9ef">new</span> MemoryCacheEntryOptions();
            options.SetAbsoluteExpiration(expirationTime);
            options.AddExpirationToken(expirationToken);

            options.PostEvictionCallbacks.Add(<span style="color:#66d9ef">new</span> PostEvictionCallbackRegistration()
            {
                EvictionCallback = (key, <span style="color:#66d9ef">value</span>, reason, state) =&gt;
                {
                    <span style="color:#66d9ef">if</span> (reason == EvictionReason.TokenExpired || reason == EvictionReason.Expired)
                    {
                        <span style="color:#75715e">// If newValue is not null - update, otherwise just refresh the old value
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// The condition by which you decide to update or refresh the data depends entirely on you
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// If you want a cache object that will never expire you can just make the following call:
</span><span style="color:#75715e"></span>                        <span style="color:#75715e">// memoryCache.Set(key, value, GetMemoryCacheEntryOptions(expireInSeconds));
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">var</span> newValue = <span style="color:#66d9ef">await</span> GetSettingsFromRemoteLocation();
                        <span style="color:#66d9ef">if</span> (newValue != <span style="color:#66d9ef">null</span>)
                        {
                            memoryCache.Set(key, newValue, GetMemoryCacheEntryOptions(expireInSeconds)); <span style="color:#75715e">// 1 hour
</span><span style="color:#75715e"></span>                        }
                        <span style="color:#66d9ef">else</span>
                        {
                            memoryCache.Set(key, <span style="color:#66d9ef">value</span>, GetMemoryCacheEntryOptions(expireInSeconds)); <span style="color:#75715e">// 1 hour
</span><span style="color:#75715e"></span>                        }
                    }
                }
            });

            <span style="color:#66d9ef">return</span> options;
        }
    }
}
</code></pre></div><p>Here we have 2 interesting behaviors we should take into consideration. Why do we need to use a cancellation token, and why won&rsquo;t the <strong><code>EvictionCallback</code></strong> execute after 1 hour without explicitly setting said token.</p>
<ul>
<li>
<p><a href="https://github.com/aspnet/Caching/issues/248">No background thread that actively scans the expiration</a>. This means we have to trigger the eviction/expiration ourselves.</p>
</li>
<li>
<p><a href="https://stackoverflow.com/a/47949111/2265179">We can trigger an expiration with the help of a CancellationToken</a></p>
</li>
</ul>
<p>To prove this to you I&rsquo;ll provide another pair of tests</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Threading;
<span style="color:#66d9ef">using</span> System.Threading.Tasks;
<span style="color:#66d9ef">using</span> Microsoft.Extensions.Caching.Memory;
<span style="color:#66d9ef">using</span> Microsoft.Extensions.Primitives;
<span style="color:#66d9ef">using</span> Microsoft.VisualStudio.TestTools.UnitTesting;

<span style="color:#66d9ef">namespace</span> FooBar.Tests
{
<span style="color:#a6e22e">    [TestClass]</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MemoryCacheTests</span>
    {
        <span style="color:#66d9ef">private</span> IMemoryCache CreateCache()
        {
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> MemoryCache(<span style="color:#66d9ef">new</span> MemoryCacheOptions()
            {
                ExpirationScanFrequency = <span style="color:#66d9ef">new</span> TimeSpan(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
            });
        }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [TestMethod]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task ExpireAndReAddFromCallbackWorks()
        {
            <span style="color:#66d9ef">var</span> cache = CreateCache();
            <span style="color:#66d9ef">var</span> initialValue = <span style="color:#e6db74">&#34;I&#39;m a value&#34;</span>;
            <span style="color:#66d9ef">var</span> newValue = <span style="color:#e6db74">&#34;I&#39;m the refreshed value&#34;</span>;
            <span style="color:#66d9ef">string</span> key = <span style="color:#e6db74">&#34;myKey&#34;</span>;
            <span style="color:#66d9ef">int</span> refreshCounter = <span style="color:#ae81ff">0</span>;

            <span style="color:#66d9ef">var</span> options = <span style="color:#66d9ef">new</span> MemoryCacheEntryOptions();
            options.SetAbsoluteExpiration(<span style="color:#66d9ef">new</span> TimeSpan(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>));
            options.PostEvictionCallbacks.Add(<span style="color:#66d9ef">new</span> PostEvictionCallbackRegistration()
            {
                EvictionCallback = (subkey, subValue, reason, state) =&gt;
                {
                    <span style="color:#66d9ef">if</span> (reason == EvictionReason.Expired)
                    {
                        cache.Set(key, newValue);
                        refreshCounter++;
                    }
                }
            });

            cache.Set(key, initialValue, options);

            <span style="color:#66d9ef">await</span> Task.Delay(TimeSpan.FromSeconds(<span style="color:#ae81ff">6</span>));

            <span style="color:#75715e">// Any activity on the cache (Get, Set, Remove) can trigger a background scan for expired items.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// There&#39;s no background thread that scans the cache for expired times
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">var</span> result = cache.Get(key);

            <span style="color:#66d9ef">await</span> Task.Delay(TimeSpan.FromSeconds(<span style="color:#ae81ff">1</span>));

            Assert.IsTrue(refreshCounter &gt;= <span style="color:#ae81ff">1</span>);
            Assert.AreEqual(newValue, cache.Get(key));
        }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">        [TestMethod]</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task TokenExpireAndReAddFromCallbackWorks()
        {
            <span style="color:#66d9ef">var</span> cache = CreateCache();
            <span style="color:#66d9ef">var</span> initialValue = <span style="color:#e6db74">&#34;I&#39;m a value&#34;</span>;
            <span style="color:#66d9ef">var</span> newValue = <span style="color:#e6db74">&#34;I&#39;m the refreshed value&#34;</span>;
            <span style="color:#66d9ef">string</span> key = <span style="color:#e6db74">&#34;myKey&#34;</span>;
            <span style="color:#66d9ef">int</span> refreshCounter = <span style="color:#ae81ff">0</span>;

            <span style="color:#66d9ef">int</span> expirationSeconds = <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">var</span> expirationTime = DateTime.Now.AddSeconds(expirationSeconds);
            <span style="color:#66d9ef">var</span> expirationToken = <span style="color:#66d9ef">new</span> CancellationChangeToken(
                <span style="color:#66d9ef">new</span> CancellationTokenSource(TimeSpan.FromSeconds(expirationSeconds + .<span style="color:#ae81ff">01</span>)).Token);

            <span style="color:#66d9ef">var</span> options = <span style="color:#66d9ef">new</span> MemoryCacheEntryOptions();
            options.SetAbsoluteExpiration(expirationTime);
            options.AddExpirationToken(expirationToken);
            options.PostEvictionCallbacks.Add(<span style="color:#66d9ef">new</span> PostEvictionCallbackRegistration()
            {
                EvictionCallback = (subkey, subValue, reason, state) =&gt;
                {
                    <span style="color:#66d9ef">if</span> (reason == EvictionReason.TokenExpired)
                    {
                        cache.Set(key, newValue);
                        refreshCounter++;
                    }
                }
            });

            cache.Set(key, initialValue, options);

            <span style="color:#66d9ef">await</span> Task.Delay(TimeSpan.FromSeconds(<span style="color:#ae81ff">6</span>));

            Assert.IsTrue(refreshCounter &gt;= <span style="color:#ae81ff">1</span>);
            Assert.AreEqual(newValue, cache.Get(key));
        }
    }
}
</code></pre></div><p>So that&rsquo;s basically it! Now we have our auto refreshing cache! There&rsquo;s a lot that we can improve. You have to be careful who has access to the keys for your specific object and a million other considerations. Caching is a steep hill to climb, but I hope you found this blog post informative in some capacity!</p>
<p>I&rsquo;ve used both implementations for some heavy objects that don&rsquo;t change often in production environments and they&rsquo;ve been doing their job pretty well so far!</p>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    Â©
    
      2017 -
    
    2022
     Pavel Danov 
    Â·
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

    </main>

    
      
      <script src="https://underscorehao.net/js/coder.min.8ddd58e878760346f67d56a123af8e6fd8dde1bc0903de1fc025ae84b4cf686f.js" integrity="sha256-jd1Y6Hh2A0b2fVahI6&#43;Ob9jd4bwJA94fwCWuhLTPaG8="></script>
    

    

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-106583563-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


    

    

    

    

    

    
  </body>

</html>
