<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Auto Refreshing Cache in .NET | Pavel Danov</title>
    <link rel="stylesheet" href="https://underscorehao.net/css/style.css" />
    <link rel="stylesheet" href="https://underscorehao.net/css/fonts.css" />
    <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css" rel="stylesheet">

  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="https://underscorehao.net/">Home</a></li>
      
      <li><a href="https://underscorehao.net/categories/">Categories</a></li>
      
      <li><a href="https://underscorehao.net/tags/">Tags</a></li>
      
      <li><a href="https://underscorehao.net/about/">About</a></li>
      
      <li><a href="https://underscorehao.net/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Auto Refreshing Cache in .NET</span></h1>

<h2 class="date">2019/07/11</h2>

<p class="terms">

  
  Categories: <a href="https://underscorehao.net/categories/software-development">Software Development</a> 
  
  
  
  Tags: <a href="https://underscorehao.net/tags/c">c#</a> <a href="https://underscorehao.net/tags/.net">.net</a> 
  
  
</p>
</div>


<nav id="TableOfContents">
  <ul>
    <li><a href="#caching-is-hard">Caching is hard</a></li>
    <li><a href="#caching-in-net">Caching in .NET</a></li>
    <li><a href="#implementation-with-memorycache-in-net-framework">Implementation with MemoryCache in .NET Framework</a>
      <ul>
        <li><a href="#bonus">Bonus</a></li>
      </ul>
    </li>
    <li><a href="#implementation-with-imemorycache-in-net-core">Implementation with IMemoryCache in .NET Core</a></li>
  </ul>
</nav>


<main>
<h2 id="caching-is-hard">Caching is hard</h2>
<p>On a bright sunny day while you&rsquo;re working on your awesome project you catch a glimpse of something. You bring yourself closer to the monitor and begin meticulously examining your code. What you find brings you feelings of disgust and shame! You&rsquo;ve been calling an API retrieving data you need over and over again even though said data hardly changes!</p>
<p>Being the smart and responsible engineer that you are, you decide to rectify your mistake immediately. You think to yourself</p>
<blockquote>
<p>&ldquo;OK, I&rsquo;ll just implement caching around that piece of data and I&rsquo;m done!&rdquo;</p>
</blockquote>
<p>Not so fast! Little do you know that you&rsquo;re opening the gates of your own small personal hell!</p>
<h2 id="caching-in-net">Caching in .NET</h2>
<p>The little story above is a <em>slight</em> exaggeration, but caching is indeed a touchy subject. It&rsquo;s a nice performance boost when done right, but it can also lead you to a dark path filled with scary monsters and unforeseen problems.</p>
<p>There are many articles written on caching in .NET, you should read the official docs and perhaps other articles written by the good people on the Internet.</p>
<p>This article however will deal with a very specific caching problem. How can you implement a cache that is refreshing itself after a specific amount of time with the following characteristics:</p>
<ul>
<li>Thread safety</li>
<li>Not getting any cache misses (even if that means we&rsquo;re returning stale data)</li>
</ul>
<p>If that&rsquo;s what you need, keep on reading!</p>
<h2 id="implementation-with-memorycache-in-net-framework">Implementation with MemoryCache in .NET Framework</h2>
<p>Let&rsquo;s start with the simple stuff. We want to perform some basic CRUD operations on our cache - saving data to it, getting our cached objects and potentially deleting our data. The best way to do it is to define an interface.</p>
<pre><code class="language-csharp">using System.Runtime.Caching;

namespace FooBar.Caching
{
    public interface IMemoryAutoRefreshCache
    {
        T GetById&lt;T&gt;(string id);
        void Save&lt;T&gt;(string id, T cacheObj, CacheItemPolicy refreshPolicy);
        void Remove(string id);
    }
}
</code></pre>
<p>These are the methods I&rsquo;m going to use to illustrate my example. Depending on your use case you can have a lot more of them doing various things to your cache, but for my case those are enough. The point I want you to focus on here is the <strong><code>CacheItemPolicy</code></strong> we can set during the Save.</p>
<p>Now that we have our interface we can also implement it in a new class</p>
<pre><code class="language-csharp">using System.Runtime.Caching;

namespace FooBar.Caching
{
    public class MemoryAutoRefreshCache : IMemoryAutoRefreshCache
    {
        private readonly MemoryCache memoryCache;

        public MemoryAutoRefreshCache(MemoryCache memoryCache = null) =&gt; this.memoryCache = memoryCache ?? MemoryCache.Default;

        public T GetById&lt;T&gt;(string id)
        {
            var value = (T)memoryCache.Get(id);
            if (value == null)
            {
                return default(T);
            }

            return value;
        }

        public void Save&lt;T&gt;(string id, T result, CacheItemPolicy refreshPolicy)
        {
            memoryCache.Set(id, result, refreshPolicy);
        }

        public void Remove(string id)
        {
            memoryCache.Remove(id);
        }
    }
}
</code></pre>
<p>Nothing out of the ordinary here. I want to bring your attention to our <strong><code>Save</code></strong> method one more time and the CacheItemPolicy. The summary of <strong><code>CacheItemPolicy</code></strong> states:</p>
<blockquote>
<p>Represents a set of eviction and expiration details for a specific cache entry.</p>
</blockquote>
<p>Inside the <strong><code>CacheItemPolicy</code></strong> we have two callbacks which will give us everything we need to accomplish our task.</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.caching.cacheentryremovedcallback?view=netframework-4.8"><strong><code>RemovedCallback</code></strong></a> - Occurs <strong><em>after</em></strong> the item has been removed</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.caching.cacheentryupdatecallback?view=netframework-4.8"><strong><code>UpdateCallback</code></strong></a> - Occurs <strong><em>before</em></strong> the item is removed</li>
</ul>
<p>As you can imagine we&rsquo;ll use the <strong><code>UpdateCallback</code></strong> in our case.</p>
<p>So let&rsquo;s see how an implementation of this auto refreshing cache will look like!</p>
<pre><code class="language-csharp">using System;
using System.Runtime.Caching;
using System.Threading;
using FooBar.Caching;

namespace FooBar.Services.Configuration
{
    public class ConfigurationProvider
    {
        private readonly IMemoryAutoRefreshCache localCache;
        private const string cacheKey = &quot;myAwesomeCacheKey&quot;;

        private static readonly object _lock = new object();

        public ConfigurationProvider(ILocalAutoRefreshCache localCache) =&gt; this.localCache = localCache;

        public Configuration GetConfiguration()
        {
            var cachedConfig = localCache.GetById&lt;Configuration&gt;(cacheKey);
            if (cachedConfig != null)
            {
                return cachedConfig;
            }

            lock (_lock)
            {
                // Check to see if anyone wrote in the cache while we're waiting for our turn
                cachedConfig = localCache.GetById&lt;Configuration&gt;(cacheKey);
                if (cachedConfig != null)
                {
                    return cachedConfig;
                }

                // This method is not implemented because it can be anything. The main part is that you want to cache an object.
                cachedConfig = GetConfigurationFromRemoteLocation(provider);
                int refreshTimeInSeconds = 3600; // 1 hour
                localCache.Save(cacheKey, cachedConfig, GetPolicy(refreshTimeInSeconds));

                return cachedConfig;
            }
        }

        private CacheItemPolicy GetPolicy(int refreshInterval)
        {
            return new CacheItemPolicy
            {
                // This is where the magic happens
                // The UpdateCallback will be called before our object is removed from the cache
                UpdateCallback = (CacheEntryUpdateArguments args) =&gt;
                {
                    if (args.RemovedReason == CacheEntryRemovedReason.Expired)
                    {
                        var cacheKey = args.Key;

                        // Get current cached value
                        var currentCachedEntity = args.Source[cacheKey] as Configuration;

                        // Get the potentially new data
                        var newEntity = GetConfigurationFromRemoteLocation(provider);

                        // If new is not null - update, otherwise just refresh the old value
                        // The condition by which you decide to update or refresh the data depends entirely on you
                        if (newEntity != null)
                        {
                            var updatedEntity = newEntity;
                            args.UpdatedCacheItem = new CacheItem(cacheKey, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                        else
                        {
                            var updatedEntity = currentCachedEntity;
                            args.UpdatedCacheItem = new CacheItem(cacheKey, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                    }
                },
                AbsoluteExpiration = DateTime.UtcNow.AddSeconds(refreshInterval),
            };
        }
    }
}
</code></pre>
<p>So there you go! Now you can refresh, update or invalidate your cache every hour depending on the behavior you desire!</p>
<h3 id="bonus">Bonus</h3>
<p>As a bonus you can read on the interesting thing that happens when you put <strong><code>AbsoluteExpiration</code></strong> below 20 seconds <a href="https://stackoverflow.com/questions/12630168/memorycache-absoluteexpiration-acting-strange">here</a>.</p>
<p>Also it&rsquo;s important to note that items can expire some time after the AbsoluteExpiration, there&rsquo;s no guarantee that they&rsquo;ll expire right on the spot. Here are two tests confirming that (I know we shouldn&rsquo;t test code that isn&rsquo;t ours, but it&rsquo;s fun!)</p>
<pre><code class="language-csharp">using FooBar.Caching;
using NUnit.Framework;
using System;
using System.Runtime.Caching;
using System.Threading;
using System.Threading.Tasks;

namespace FooBar.Caching.UnitTests
{
    [TestFixture]
    public class MemoryAutoRefreshCacheTests
    {
        private MemoryAutoRefreshCache subject;
        private int updateItemCounter = 0;

        [SetUp]
        public void Setup() =&gt; subject = new MemoryAutoRefreshCache();

        [Test]
        public async Task VerifyUpdateCallback_LocalMemoryCache()
        {
            updateItemCounter = 0;

            subject.Save($&quot;key&quot;, &quot;value&quot;, GetPolicy(1));

            // The item can be expired between 0 and 30 seconds after expiration time
            await Task.Delay(TimeSpan.FromSeconds(32));

            // Test that the update callback was invoked at least once
            Assert.IsTrue(updateItemCounter &gt;= 1);
        }

        [Test]
        public void VerifyUpdateCallbackReturnsDuringRefresh_LocalMemoryCache()
        {
            updateItemCounter = 0;

            string key = &quot;key&quot;;
            string value = &quot;value&quot;;

            subject.Save(key, value, GetPolicyWithDelay(1));

            // The item can be expired between 0 and 30 seconds after expiration time
            var start = DateTime.UtcNow;

            do
            {
                var cachedItem = subject.GetById&lt;string&gt;(&quot;key&quot;);
                Assert.AreEqual(value, cachedItem);
            } while (start.AddSeconds(40) &gt; DateTime.UtcNow);

            Assert.IsTrue(updateItemCounter &gt;= 1);
        }

        private string AddKeys(string key)
        {
            updateItemCounter++;
            return key + key;
        }

        private void UpdateCounter()
        {
            updateItemCounter++;
        }

        private CacheItemPolicy GetPolicyWithDelay(double refreshInterval)
        {
            return new CacheItemPolicy
            {
                UpdateCallback = (CacheEntryUpdateArguments args) =&gt;
                {
                    if (args.RemovedReason == CacheEntryRemovedReason.Expired)
                    {
                        Thread.Sleep(2000);
                        var id = args.Key;

                        // Get current cached value
                        var currentCachedEntity = args.Source[id] as string;
                        UpdateCounter();

                        var newEntity = args.Source[id];

                        // If new is not null - update, otherwise just refresh the old value
                        if (newEntity != null)
                        {
                            var updatedEntity = newEntity;
                            args.UpdatedCacheItem = new CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                        else
                        {
                            var updatedEntity = currentCachedEntity;
                            args.UpdatedCacheItem = new CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }

                    }
                },
                AbsoluteExpiration = DateTimeOffset.UtcNow.AddSeconds(refreshInterval)
            };
        }

        private CacheItemPolicy GetPolicy(double refreshInterval)
        {
            return new CacheItemPolicy
            {
                UpdateCallback = (CacheEntryUpdateArguments args) =&gt;
                {
                    if (args.RemovedReason == CacheEntryRemovedReason.Expired)
                    {
                        var id = args.Key;

                        // Get current cached value
                        var currentCachedEntity = args.Source[id] as string;

                        var newEntity = AddKeys(id);

                        // If new is not null - update, otherwise just refresh the old value
                        if (newEntity != null)
                        {
                            var updatedEntity = newEntity;
                            args.UpdatedCacheItem = new CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                        else
                        {
                            var updatedEntity = currentCachedEntity;
                            args.UpdatedCacheItem = new CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }

                    }
                },
                SlidingExpiration = TimeSpan.FromSeconds(refreshInterval),
            };
        }
    }
}
</code></pre>
<h2 id="implementation-with-imemorycache-in-net-core">Implementation with IMemoryCache in .NET Core</h2>
<p>I have a strong feeling a lot of people will come to read this article for the part that follows&hellip; Who cares about .NET Framework, amirite?! It&rsquo;s all about .NET Core nowadays, son!</p>
<p>I&rsquo;d be lying if I didn&rsquo;t say that I prefer the .NET Core implementation. But I digress. Let&rsquo;s stay on the issue at hand - implementing an auto refreshing cache.</p>
<p>We still have access to <strong><code>MemoryCache</code></strong> in .NET Core. However it only provides a callback which will execute <strong><em>after</em></strong> an item has been <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.postevictioncallbacks?view=aspnetcore-2.2#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_PostEvictionCallbacks">removed</a>. That doesn&rsquo;t matter for our use case. Remember what we said at the start. We don&rsquo;t care if we get stale data as long as there are no cache misses! To achieve the same thing we did in the previous section we are going to use a shiny new interface called <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.imemorycache?view=aspnetcore-2.2"><strong><code>IMemoryCache</code></strong></a>. And guess what! It&rsquo;s provided by Microsoft too!</p>
<p>The code is more or less the same with some differences when it comes to the locking. This time we&rsquo;re performing operations inside an async method so we can&rsquo;t use a regular lock. For the sake of completeness I&rsquo;ll provide the full implementation + tests and gotchas after.</p>
<pre><code class="language-csharp">using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Memory;

namespace FooBar.Providers
{
    public class SettingsStore
    {
        private const string cacheKey = &quot;FooBarPrivateKey&quot;;
        private const int refreshTimeInSeconds = 3600;
        private readonly IMemoryCache memoryCache;
        private readonly ConcurrentDictionary&lt;object, SemaphoreSlim&gt; locks = new ConcurrentDictionary&lt;object, SemaphoreSlim&gt;();

        public SettingsStore(IMemoryCache memoryCache) =&gt; this.memoryCache = memoryCache;

        public async Task&lt;Settings&gt; GetSettingsAsync()
        {
            // Normal lock doesn't work in async code
            if (!memoryCache.TryGetValue(cacheKey, out Settings settings))
            {
                SemaphoreSlim certLock = locks.GetOrAdd(cacheKey, k =&gt; new SemaphoreSlim(1, 1));
                await certLock.WaitAsync();

                try
                {
                    if (!memoryCache.TryGetValue(cacheKey, out settings))
                    {
                        // This method is not implemented because it can be anything.
                        // The main part is that you want to cache an object.
                        settings = await GetSettingsFromRemoteLocation();
                        memoryCache.Set(cacheKey, settings, GetMemoryCacheEntryOptions(refreshTimeInSeconds)); // 1 hour
                    }
                }
                finally
                {
                    certLock.Release();
                }
            }
            return settings;
        }

        private MemoryCacheEntryOptions GetMemoryCacheEntryOptions(int expireInSeconds = 3600)
        {
            var expirationTime = DateTime.Now.AddSeconds(expireInSeconds);
            var expirationToken = new CancellationChangeToken(
                new CancellationTokenSource(TimeSpan.FromSeconds(expireInSeconds + .01)).Token);

            var options = new MemoryCacheEntryOptions();
            options.SetAbsoluteExpiration(expirationTime);
            options.AddExpirationToken(expirationToken);

            options.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration()
            {
                EvictionCallback = (key, value, reason, state) =&gt;
                {
                    if (reason == EvictionReason.TokenExpired || reason == EvictionReason.Expired)
                    {
                        // If newValue is not null - update, otherwise just refresh the old value
                        // The condition by which you decide to update or refresh the data depends entirely on you
                        // If you want a cache object that will never expire you can just make the following call:
                        // memoryCache.Set(key, value, GetMemoryCacheEntryOptions(expireInSeconds));
                        var newValue = await GetSettingsFromRemoteLocation();
                        if (newValue != null)
                        {
                            memoryCache.Set(key, newValue, GetMemoryCacheEntryOptions(expireInSeconds)); // 1 hour
                        }
                        else
                        {
                            memoryCache.Set(key, value, GetMemoryCacheEntryOptions(expireInSeconds)); // 1 hour
                        }
                    }
                }
            });

            return options;
        }
    }
}
</code></pre>
<p>Here we have 2 interesting behaviors we should take into consideration. Why do we need to use a cancellation token, and why won&rsquo;t the <strong><code>EvictionCallback</code></strong> execute after 1 hour without explicitly setting said token.</p>
<ul>
<li>
<p><a href="https://github.com/aspnet/Caching/issues/248">No background thread that actively scans the expiration</a>. This means we have to trigger the eviction/expiration ourselves.</p>
</li>
<li>
<p><a href="https://stackoverflow.com/a/47949111/2265179">We can trigger an expiration with the help of a CancellationToken</a></p>
</li>
</ul>
<p>To prove this to you I&rsquo;ll provide another pair of tests</p>
<pre><code class="language-csharp">using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Primitives;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace FooBar.Tests
{
    [TestClass]
    public class MemoryCacheTests
    {
        private IMemoryCache CreateCache()
        {
            return new MemoryCache(new MemoryCacheOptions()
            {
                ExpirationScanFrequency = new TimeSpan(0, 0, 1)
            });
        }

        [TestMethod]
        public async Task ExpireAndReAddFromCallbackWorks()
        {
            var cache = CreateCache();
            var initialValue = &quot;I'm a value&quot;;
            var newValue = &quot;I'm the refreshed value&quot;;
            string key = &quot;myKey&quot;;
            int refreshCounter = 0;

            var options = new MemoryCacheEntryOptions();
            options.SetAbsoluteExpiration(new TimeSpan(0, 0, 1));
            options.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration()
            {
                EvictionCallback = (subkey, subValue, reason, state) =&gt;
                {
                    if (reason == EvictionReason.Expired)
                    {
                        cache.Set(key, newValue);
                        refreshCounter++;
                    }
                }
            });

            cache.Set(key, initialValue, options);

            await Task.Delay(TimeSpan.FromSeconds(6));

            // Any activity on the cache (Get, Set, Remove) can trigger a background scan for expired items.
            // There's no background thread that scans the cache for expired times
            var result = cache.Get(key);

            await Task.Delay(TimeSpan.FromSeconds(1));

            Assert.IsTrue(refreshCounter &gt;= 1);
            Assert.AreEqual(newValue, cache.Get(key));
        }

        [TestMethod]
        public async Task TokenExpireAndReAddFromCallbackWorks()
        {
            var cache = CreateCache();
            var initialValue = &quot;I'm a value&quot;;
            var newValue = &quot;I'm the refreshed value&quot;;
            string key = &quot;myKey&quot;;
            int refreshCounter = 0;

            int expirationSeconds = 1;
            var expirationTime = DateTime.Now.AddSeconds(expirationSeconds);
            var expirationToken = new CancellationChangeToken(
                new CancellationTokenSource(TimeSpan.FromSeconds(expirationSeconds + .01)).Token);

            var options = new MemoryCacheEntryOptions();
            options.SetAbsoluteExpiration(expirationTime);
            options.AddExpirationToken(expirationToken);
            options.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration()
            {
                EvictionCallback = (subkey, subValue, reason, state) =&gt;
                {
                    if (reason == EvictionReason.TokenExpired)
                    {
                        cache.Set(key, newValue);
                        refreshCounter++;
                    }
                }
            });

            cache.Set(key, initialValue, options);

            await Task.Delay(TimeSpan.FromSeconds(6));

            Assert.IsTrue(refreshCounter &gt;= 1);
            Assert.AreEqual(newValue, cache.Get(key));
        }
    }
}
</code></pre>
<p>So that&rsquo;s basically it! Now we have our auto refreshing cache! There&rsquo;s a lot that we can improve. You have to be careful who has access to the keys for your specific object and a million other considerations. Caching is a steep hill to climb, but I hope you found this blog post informative in some capacity!</p>
<p>I&rsquo;ve used both implementations for some heavy objects that don&rsquo;t change often in production environments and they&rsquo;ve been doing their job pretty well so far!</p>

</main>

  <footer>
  <script defer src="//yihui.org/js/math-code.js"></script>
<script defer src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script defer src="//yihui.org/js/center-img.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-106583563-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js" integrity="sha512-gU7kztaQEl7SHJyraPfZLQCNnrKdaQi5ndOyt4L4UPL/FHDd/uB9Je6KDARIqwnNNE27hnqoWLBq+Kpe4iHfeQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
hljs.configure({languages: []});
hljs.initHighlightingOnLoad();
</script>

  
  <hr/>
  © <a href="mailto:underscorehao@gmail.com">Pavel Danov</a> 2017 &ndash; 2022 | <a href="https://github.com/underscoreHao/">Github</a> | <a href="https://twitter.com/underscoreHao">Twitter</a> | <a href="https://stackoverflow.com/users/2265179/underscorehao">StackOverflow</a> | <a href="https://www.linkedin.com/in/pavel-danov/">LinkedIn</a>
  
  </footer>
  </body>
</html>

