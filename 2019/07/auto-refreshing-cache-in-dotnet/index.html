














<!DOCTYPE html>
<html lang='en'><head>
    <meta charset="utf-8">
    <link rel="shortcut icon" href='/favicon.ico' type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Auto Refreshing Cache in .NET - Pavel Danov</title>

    

    

    
    <meta name="author" content="Pavel Danov" />
    

    
        <meta property="og:title" content="Auto Refreshing Cache in .NET" />
<meta property="og:description" content="Caching is hard On a bright sunny day while you&rsquo;re working on your awesome project you catch a glimpse of something. You bring yourself closer to the monitor and begin meticulously examining your code. What you find brings you feelings of disgust and shame! You&rsquo;ve been calling an API retrieving data you need over and over again even though said data hardly changes!
Being the smart and responsible engineer that you are, you decide to rectify your mistake immediately." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://underscorehao.net/2019/07/auto-refreshing-cache-in-dotnet/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-11T22:47:02+01:00" />
<meta property="article:modified_time" content="2019-07-11T22:47:02+01:00" />


    

    
        <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Auto Refreshing Cache in .NET"/>
<meta name="twitter:description" content="Caching is hard On a bright sunny day while you&rsquo;re working on your awesome project you catch a glimpse of something. You bring yourself closer to the monitor and begin meticulously examining your code. What you find brings you feelings of disgust and shame! You&rsquo;ve been calling an API retrieving data you need over and over again even though said data hardly changes!
Being the smart and responsible engineer that you are, you decide to rectify your mistake immediately."/>

    <link rel="stylesheet" href="/style.min.5297c96c59a52afaa5bcda4a6cedf3813081f64025c209b25b2ee6d0c8f74d462b625ad3404a92a14d7a51b4ec0a420337ae70f426fa4bce2d5f7459a3ca7274.css" integrity="sha512-UpfJbFmlKvqlvNpKbO3zgTCB9kAlwgmyWy7m0Mj3TUYrYlrTQEqSoU16UbTsCkIDN65w9Cb6S84tX3RZo8pydA==">



    <link rel="stylesheet" href="/lib/css/prism.min.6226f06f992e0d6166b0e26724efd050dcc381202a752892ba523b1b865de2ea5e427f8f7d10de682fc35d6e7444018247d1f25db5e1e3bab17068ce191c5886.css" integrity="sha512-Yibwb5kuDWFmsOJnJO/QUNzDgSAqdSiSulI7G4Zd4upeQn&#43;PfRDeaC/DXW50RAGCR9HyXbXh47qxcGjOGRxYhg==">


        
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-106583563-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    

    
    <script>
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.setAttribute("data-theme", "dark");
        } else {
            document.documentElement.setAttribute("data-theme", "light");
        }
    </script>
<script defer src="/js/header.7a2a109ec3782c57bad0332b662f8a5f41765505936b69868eb8bd5241de9daf23c388e82ca1831f6d09935013dcb9f71bfa7face3975880c1076028b7b0a6e1.js" integrity="sha512-eioQnsN4LFe60DMrZi&#43;KX0F2VQWTa2mGjri9UkHena8jw4joLKGDH20Jk1AT3Ln3G/p/rOOXWIDBB2Aot7Cm4Q=="></script>



    <script defer src="/js/zooming.fc76b730bcba24949cb337c58c5e935f727dbea8418e918e3b1794f0707d130aadf4ead341e9305a2c6045f7bc66700d73cc5c7f5d8f6ae2c7631e095f4e18ae.js" integrity="sha512-/Ha3MLy6JJScszfFjF6TX3J9vqhBjpGOOxeU8HB9Ewqt9OrTQekwWixgRfe8ZnANc8xcf12PauLHYx4JX04Yrg=="></script>




    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script defer src="/js/math.d7efde37b2eb8879651e1f4489bcd4d8203b8c2bf8ca12c9e1b8cd11bfd6395b172f4999fff43ce0d047889a2bdb71ee74aebbae5327590192d1144e790fcd7b.js" integrity="sha512-1&#43;/eN7LriHllHh9EibzU2CA7jCv4yhLJ4bjNEb/WOVsXL0mZ//Q84NBHiJor23HudK67rlMnWQGS0RROeQ/New=="></script>




    
        

        
        

        
        
            
        

        <script defer src="/js/prism.3113e52d215fde553c8747fb87544cc26ae5ab9b25e8ab7e7ab767824138bca8c0edb05a3c2d6dbcda075db565c7025817f6f6eea26a5d14c4e53397ae7748e2.js" integrity="sha512-MRPlLSFf3lU8h0f7h1RMwmrlq5sl6Kt&#43;erdngkE4vKjA7bBaPC1tvNoHXbVlxwJYF/b27qJqXRTE5TOXrndI4g==" data-manual></script>
    



    
    
    
    <script defer src="/js/search-en.677e05c714f837051483647d736c45051126c22a2696ca5f981b59da962d48962f3ea71150f559ba84884fd1aadf1c7aadce55bb31a3e5b75c0f173b763c109a.js" integrity="sha512-Z34FxxT4NwUUg2R9c2xFBREmwiomlspfmBtZ2pYtSJYvPqcRUPVZuoSIT9Gq3xx6rc5VuzGj5bdcDxc7djwQmg=="></script>




</head><body>
        <main><header>
    <div class="brand">
        <div id="sidebar_btn">
            <svg id="menu_icon" width="26px" height="26px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></svg>
        </div>

        <div>
            <a href="/">Pavel Danov</a>
        </div>
    </div>

    <div class="toolbox">
        <div id="theme_tool">
            <svg id="dark_mode_btn" class="hidden toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></svg>
            <svg id="light_mode_btn" class="hidden toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></svg>
        </div>

        
            <div id="search_tool">
                <svg id="search_btn" class="toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></svg><div id="search_menu_wrapper" class="hidden">
    <div id="search_menu">
        <div id="search_menu_toolbar">
            <div id="search_menu_input_wrapper">
                <input id="search_menu_input" type="text" placeholder='Search Posts'>
            </div>
            <div id="search_menu_close_btn">
                <svg width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></svg>
            </div>
        </div>
        <div id="search_menu_results">
        </div>
    </div>
</div>
</div>
        

        
            <div id="translation_tool" class="dropdown-wrapper pure-menu pure-menu-horizontal toolbox-btn">
                <ul class="pure-menu-list">
                    <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
                        <div class="dropdown-btn pure-menu-link">
                            <svg width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-globe"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg></svg>
                            <span class="dropdown-desc">English</span>
                        </div>
                        <ul class="pure-menu-children">
                            
                            <li class="pure-menu-item">
                                <a href="https://underscorehao.net/" class="pure-menu-link">English</a>
                            </li>
                            
                            <li class="pure-menu-item">
                                <a href="https://underscorehao.net/bg/" class="pure-menu-link">Български</a>
                            </li>
                            
                        </ul>
                    </li>
                </ul>
            </div>
        
    </div>
</header>
<nav id="navbar" class="pure-menu"><ul class="pure-menu-list"><li class="navbar-item pure-menu-item ">
                    
                        <a href="/posts/" class="pure-menu-link">Blog</a>
                    
                </li><li class="navbar-item pure-menu-item ">
                    
                        <a href="/notes/" class="pure-menu-link">Notes</a>
                    
                </li></ul>
</nav>
<div id="sidebar_canvas_overlay" class="hidden"></div>
<div id="sidebar" class="close">
    <ul><li>
                    <a href="/posts/">Blog</a>
                </li><li>
                    <a href="/notes/">Notes</a>
                </li></ul>
</div><div id="content" class="content-margin">
                
    
    <div class="collapsible-menu-wrapper"><div class="collapsible-menu-type"><span>Table of contents</span></div><div class="collapsible-menu">
        
            <nav id="TableOfContents">
  <ul>
    <li><a href="#caching-is-hard">Caching is hard</a></li>
    <li><a href="#caching-in-net">Caching in .NET</a></li>
    <li><a href="#implementation-with-memorycache-in-net-framework">Implementation with MemoryCache in .NET Framework</a>
      <ul>
        <li><a href="#bonus">Bonus</a></li>
      </ul>
    </li>
    <li><a href="#implementation-with-imemorycache-in-net-core">Implementation with IMemoryCache in .NET Core</a></li>
  </ul>
</nav>
        
    </div></div>



    <div class="content-margin">

<article >
    
    
        
        
    
    <h2 id="caching-is-hard">Caching is hard</h2>
<p>On a bright sunny day while you&rsquo;re working on your awesome project you catch a glimpse of something. You bring yourself closer to the monitor and begin meticulously examining your code. What you find brings you feelings of disgust and shame! You&rsquo;ve been calling an API retrieving data you need over and over again even though said data hardly changes!</p>
<p>Being the smart and responsible engineer that you are, you decide to rectify your mistake immediately. You think to yourself</p>
<blockquote>
<p>&ldquo;OK, I&rsquo;ll just implement caching around that piece of data and I&rsquo;m done!&rdquo;</p>
</blockquote>
<p>Not so fast! Little do you know that you&rsquo;re opening the gates of your own small personal hell!</p>
<h2 id="caching-in-net">Caching in .NET</h2>
<p>The little story above is a <em>slight</em> exaggeration, but caching is indeed a touchy subject. It&rsquo;s a nice performance boost when done right, but it can also lead you to a dark path filled with scary monsters and unforeseen problems.</p>
<p>There are many articles written on caching in .NET, you should read the official docs and perhaps other articles written by the good people on the Internet.</p>
<p>This article however will deal with a very specific caching problem. How can you implement a cache that is refreshing itself after a specific amount of time with the following characteristics:</p>
<ul>
<li>Thread safety</li>
<li>Not getting any cache misses (even if that means we&rsquo;re returning stale data)</li>
</ul>
<p>If that&rsquo;s what you need, keep on reading!</p>
<h2 id="implementation-with-memorycache-in-net-framework">Implementation with MemoryCache in .NET Framework</h2>
<p>Let&rsquo;s start with the simple stuff. We want to perform some basic CRUD operations on our cache - saving data to it, getting our cached objects and potentially deleting our data. The best way to do it is to define an interface.</p>
<pre  class="mc-prism hide language-text" ><code class="language-csharp">using System.Runtime.Caching;

namespace FooBar.Caching
{
    public interface IMemoryAutoRefreshCache
    {
        T GetById&lt;T&gt;(string id);
        void Save&lt;T&gt;(string id, T cacheObj, CacheItemPolicy refreshPolicy);
        void Remove(string id);
    }
}
</code></pre>
<p>These are the methods I&rsquo;m going to use to illustrate my example. Depending on your use case you can have a lot more of them doing various things to your cache, but for my case those are enough. The point I want you to focus on here is the <strong><code>CacheItemPolicy</code></strong> we can set during the Save.</p>
<p>Now that we have our interface we can also implement it in a new class</p>
<pre  class="mc-prism hide language-text" ><code class="language-csharp">using System.Runtime.Caching;

namespace FooBar.Caching
{
    public class MemoryAutoRefreshCache : IMemoryAutoRefreshCache
    {
        private readonly MemoryCache memoryCache;

        public MemoryAutoRefreshCache(MemoryCache memoryCache = null) =&gt; this.memoryCache = memoryCache ?? MemoryCache.Default;

        public T GetById&lt;T&gt;(string id)
        {
            var value = (T)memoryCache.Get(id);
            if (value == null)
            {
                return default(T);
            }

            return value;
        }

        public void Save&lt;T&gt;(string id, T result, CacheItemPolicy refreshPolicy)
        {
            memoryCache.Set(id, result, refreshPolicy);
        }

        public void Remove(string id)
        {
            memoryCache.Remove(id);
        }
    }
}
</code></pre>
<p>Nothing out of the ordinary here. I want to bring your attention to our <strong><code>Save</code></strong> method one more time and the CacheItemPolicy. The summary of <strong><code>CacheItemPolicy</code></strong> states:</p>
<blockquote>
<p>Represents a set of eviction and expiration details for a specific cache entry.</p>
</blockquote>
<p>Inside the <strong><code>CacheItemPolicy</code></strong> we have two callbacks which will give us everything we need to accomplish our task.</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.caching.cacheentryremovedcallback?view=netframework-4.8"><strong><code>RemovedCallback</code></strong></a> - Occurs <strong><em>after</em></strong> the item has been removed</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.caching.cacheentryupdatecallback?view=netframework-4.8"><strong><code>UpdateCallback</code></strong></a> - Occurs <strong><em>before</em></strong> the item is removed</li>
</ul>
<p>As you can imagine we&rsquo;ll use the <strong><code>UpdateCallback</code></strong> in our case.</p>
<p>So let&rsquo;s see how an implementation of this auto refreshing cache will look like!</p>
<pre  class="mc-prism hide language-text" ><code class="language-csharp">using System;
using System.Runtime.Caching;
using System.Threading;
using FooBar.Caching;

namespace FooBar.Services.Configuration
{
    public class ConfigurationProvider
    {
        private readonly IMemoryAutoRefreshCache localCache;
        private const string cacheKey = &quot;myAwesomeCacheKey&quot;;

        private static readonly object _lock = new object();

        public ConfigurationProvider(ILocalAutoRefreshCache localCache) =&gt; this.localCache = localCache;

        public Configuration GetConfiguration()
        {
            var cachedConfig = localCache.GetById&lt;Configuration&gt;(cacheKey);
            if (cachedConfig != null)
            {
                return cachedConfig;
            }

            lock (_lock)
            {
                // Check to see if anyone wrote in the cache while we're waiting for our turn
                cachedConfig = localCache.GetById&lt;Configuration&gt;(cacheKey);
                if (cachedConfig != null)
                {
                    return cachedConfig;
                }

                // This method is not implemented because it can be anything. The main part is that you want to cache an object.
                cachedConfig = GetConfigurationFromRemoteLocation(provider);
                int refreshTimeInSeconds = 3600; // 1 hour
                localCache.Save(cacheKey, cachedConfig, GetPolicy(refreshTimeInSeconds));

                return cachedConfig;
            }
        }

        private CacheItemPolicy GetPolicy(int refreshInterval)
        {
            return new CacheItemPolicy
            {
                // This is where the magic happens
                // The UpdateCallback will be called before our object is removed from the cache
                UpdateCallback = (CacheEntryUpdateArguments args) =&gt;
                {
                    if (args.RemovedReason == CacheEntryRemovedReason.Expired)
                    {
                        var cacheKey = args.Key;

                        // Get current cached value
                        var currentCachedEntity = args.Source[cacheKey] as Configuration;

                        // Get the potentially new data
                        var newEntity = GetConfigurationFromRemoteLocation(provider);

                        // If new is not null - update, otherwise just refresh the old value
                        // The condition by which you decide to update or refresh the data depends entirely on you
                        if (newEntity != null)
                        {
                            var updatedEntity = newEntity;
                            args.UpdatedCacheItem = new CacheItem(cacheKey, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                        else
                        {
                            var updatedEntity = currentCachedEntity;
                            args.UpdatedCacheItem = new CacheItem(cacheKey, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                    }
                },
                AbsoluteExpiration = DateTime.UtcNow.AddSeconds(refreshInterval),
            };
        }
    }
}
</code></pre>
<p>So there you go! Now you can refresh, update or invalidate your cache every hour depending on the behavior you desire!</p>
<h3 id="bonus">Bonus</h3>
<p>As a bonus you can read on the interesting thing that happens when you put <strong><code>AbsoluteExpiration</code></strong> below 20 seconds <a href="https://stackoverflow.com/questions/12630168/memorycache-absoluteexpiration-acting-strange">here</a>.</p>
<p>Also it&rsquo;s important to note that items can expire some time after the AbsoluteExpiration, there&rsquo;s no guarantee that they&rsquo;ll expire right on the spot. Here are two tests confirming that (I know we shouldn&rsquo;t test code that isn&rsquo;t ours, but it&rsquo;s fun!)</p>
<pre  class="mc-prism hide language-text" ><code class="language-csharp">using FooBar.Caching;
using NUnit.Framework;
using System;
using System.Runtime.Caching;
using System.Threading;
using System.Threading.Tasks;

namespace FooBar.Caching.UnitTests
{
    [TestFixture]
    public class MemoryAutoRefreshCacheTests
    {
        private MemoryAutoRefreshCache subject;
        private int updateItemCounter = 0;

        [SetUp]
        public void Setup() =&gt; subject = new MemoryAutoRefreshCache();

        [Test]
        public async Task VerifyUpdateCallback_LocalMemoryCache()
        {
            updateItemCounter = 0;

            subject.Save($&quot;key&quot;, &quot;value&quot;, GetPolicy(1));

            // The item can be expired between 0 and 30 seconds after expiration time
            await Task.Delay(TimeSpan.FromSeconds(32));

            // Test that the update callback was invoked at least once
            Assert.IsTrue(updateItemCounter &gt;= 1);
        }

        [Test]
        public void VerifyUpdateCallbackReturnsDuringRefresh_LocalMemoryCache()
        {
            updateItemCounter = 0;

            string key = &quot;key&quot;;
            string value = &quot;value&quot;;

            subject.Save(key, value, GetPolicyWithDelay(1));

            // The item can be expired between 0 and 30 seconds after expiration time
            var start = DateTime.UtcNow;

            do
            {
                var cachedItem = subject.GetById&lt;string&gt;(&quot;key&quot;);
                Assert.AreEqual(value, cachedItem);
            } while (start.AddSeconds(40) &gt; DateTime.UtcNow);

            Assert.IsTrue(updateItemCounter &gt;= 1);
        }

        private string AddKeys(string key)
        {
            updateItemCounter++;
            return key + key;
        }

        private void UpdateCounter()
        {
            updateItemCounter++;
        }

        private CacheItemPolicy GetPolicyWithDelay(double refreshInterval)
        {
            return new CacheItemPolicy
            {
                UpdateCallback = (CacheEntryUpdateArguments args) =&gt;
                {
                    if (args.RemovedReason == CacheEntryRemovedReason.Expired)
                    {
                        Thread.Sleep(2000);
                        var id = args.Key;

                        // Get current cached value
                        var currentCachedEntity = args.Source[id] as string;
                        UpdateCounter();

                        var newEntity = args.Source[id];

                        // If new is not null - update, otherwise just refresh the old value
                        if (newEntity != null)
                        {
                            var updatedEntity = newEntity;
                            args.UpdatedCacheItem = new CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                        else
                        {
                            var updatedEntity = currentCachedEntity;
                            args.UpdatedCacheItem = new CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }

                    }
                },
                AbsoluteExpiration = DateTimeOffset.UtcNow.AddSeconds(refreshInterval)
            };
        }

        private CacheItemPolicy GetPolicy(double refreshInterval)
        {
            return new CacheItemPolicy
            {
                UpdateCallback = (CacheEntryUpdateArguments args) =&gt;
                {
                    if (args.RemovedReason == CacheEntryRemovedReason.Expired)
                    {
                        var id = args.Key;

                        // Get current cached value
                        var currentCachedEntity = args.Source[id] as string;

                        var newEntity = AddKeys(id);

                        // If new is not null - update, otherwise just refresh the old value
                        if (newEntity != null)
                        {
                            var updatedEntity = newEntity;
                            args.UpdatedCacheItem = new CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }
                        else
                        {
                            var updatedEntity = currentCachedEntity;
                            args.UpdatedCacheItem = new CacheItem(id, updatedEntity);
                            args.UpdatedCacheItemPolicy = GetPolicy(refreshInterval);
                        }

                    }
                },
                SlidingExpiration = TimeSpan.FromSeconds(refreshInterval),
            };
        }
    }
}
</code></pre>
<h2 id="implementation-with-imemorycache-in-net-core">Implementation with IMemoryCache in .NET Core</h2>
<p>I have a strong feeling a lot of people will come to read this article for the part that follows&hellip; Who cares about .NET Framework, amirite?! It&rsquo;s all about .NET Core nowadays, son!</p>
<p>I&rsquo;d be lying if I didn&rsquo;t say that I prefer the .NET Core implementation. But I digress. Let&rsquo;s stay on the issue at hand - implementing an auto refreshing cache.</p>
<p>We still have access to <strong><code>MemoryCache</code></strong> in .NET Core. However it only provides a callback which will execute <strong><em>after</em></strong> an item has been <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.postevictioncallbacks?view=aspnetcore-2.2#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_PostEvictionCallbacks">removed</a>. That doesn&rsquo;t matter for our use case. Remember what we said at the start. We don&rsquo;t care if we get stale data as long as there are no cache misses! To achieve the same thing we did in the previous section we are going to use a shiny new interface called <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.imemorycache?view=aspnetcore-2.2"><strong><code>IMemoryCache</code></strong></a>. And guess what! It&rsquo;s provided by Microsoft too!</p>
<p>The code is more or less the same with some differences when it comes to the locking. This time we&rsquo;re performing operations inside an async method so we can&rsquo;t use a regular lock. For the sake of completeness I&rsquo;ll provide the full implementation + tests and gotchas after.</p>
<pre  class="mc-prism hide language-text" ><code class="language-csharp">using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Memory;

namespace FooBar.Providers
{
    public class SettingsStore
    {
        private const string cacheKey = &quot;FooBarPrivateKey&quot;;
        private const int refreshTimeInSeconds = 3600;
        private readonly IMemoryCache memoryCache;
        private readonly ConcurrentDictionary&lt;object, SemaphoreSlim&gt; locks = new ConcurrentDictionary&lt;object, SemaphoreSlim&gt;();

        public SettingsStore(IMemoryCache memoryCache) =&gt; this.memoryCache = memoryCache;

        public async Task&lt;Settings&gt; GetSettingsAsync()
        {
            // Normal lock doesn't work in async code
            if (!memoryCache.TryGetValue(cacheKey, out Settings settings))
            {
                SemaphoreSlim certLock = locks.GetOrAdd(cacheKey, k =&gt; new SemaphoreSlim(1, 1));
                await certLock.WaitAsync();

                try
                {
                    if (!memoryCache.TryGetValue(cacheKey, out settings))
                    {
                        // This method is not implemented because it can be anything.
                        // The main part is that you want to cache an object.
                        settings = await GetSettingsFromRemoteLocation();
                        memoryCache.Set(cacheKey, settings, GetMemoryCacheEntryOptions(refreshTimeInSeconds)); // 1 hour
                    }
                }
                finally
                {
                    certLock.Release();
                }
            }
            return settings;
        }

        private MemoryCacheEntryOptions GetMemoryCacheEntryOptions(int expireInSeconds = 3600)
        {
            var expirationTime = DateTime.Now.AddSeconds(expireInSeconds);
            var expirationToken = new CancellationChangeToken(
                new CancellationTokenSource(TimeSpan.FromSeconds(expireInSeconds + .01)).Token);

            var options = new MemoryCacheEntryOptions();
            options.SetAbsoluteExpiration(expirationTime);
            options.AddExpirationToken(expirationToken);

            options.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration()
            {
                EvictionCallback = (key, value, reason, state) =&gt;
                {
                    if (reason == EvictionReason.TokenExpired || reason == EvictionReason.Expired)
                    {
                        // If newValue is not null - update, otherwise just refresh the old value
                        // The condition by which you decide to update or refresh the data depends entirely on you
                        // If you want a cache object that will never expire you can just make the following call:
                        // memoryCache.Set(key, value, GetMemoryCacheEntryOptions(expireInSeconds));
                        var newValue = await GetSettingsFromRemoteLocation();
                        if (newValue != null)
                        {
                            memoryCache.Set(key, newValue, GetMemoryCacheEntryOptions(expireInSeconds)); // 1 hour
                        }
                        else
                        {
                            memoryCache.Set(key, value, GetMemoryCacheEntryOptions(expireInSeconds)); // 1 hour
                        }
                    }
                }
            });

            return options;
        }
    }
}
</code></pre>
<p>Here we have 2 interesting behaviors we should take into consideration. Why do we need to use a cancellation token, and why won&rsquo;t the <strong><code>EvictionCallback</code></strong> execute after 1 hour without explicitly setting said token.</p>
<ul>
<li>
<p><a href="https://github.com/aspnet/Caching/issues/248">No background thread that actively scans the expiration</a>. This means we have to trigger the eviction/expiration ourselves.</p>
</li>
<li>
<p><a href="https://stackoverflow.com/a/47949111/2265179">We can trigger an expiration with the help of a CancellationToken</a></p>
</li>
</ul>
<p>To prove this to you I&rsquo;ll provide another pair of tests</p>
<pre  class="mc-prism hide language-text" ><code class="language-csharp">using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Primitives;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace FooBar.Tests
{
    [TestClass]
    public class MemoryCacheTests
    {
        private IMemoryCache CreateCache()
        {
            return new MemoryCache(new MemoryCacheOptions()
            {
                ExpirationScanFrequency = new TimeSpan(0, 0, 1)
            });
        }

        [TestMethod]
        public async Task ExpireAndReAddFromCallbackWorks()
        {
            var cache = CreateCache();
            var initialValue = &quot;I'm a value&quot;;
            var newValue = &quot;I'm the refreshed value&quot;;
            string key = &quot;myKey&quot;;
            int refreshCounter = 0;

            var options = new MemoryCacheEntryOptions();
            options.SetAbsoluteExpiration(new TimeSpan(0, 0, 1));
            options.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration()
            {
                EvictionCallback = (subkey, subValue, reason, state) =&gt;
                {
                    if (reason == EvictionReason.Expired)
                    {
                        cache.Set(key, newValue);
                        refreshCounter++;
                    }
                }
            });

            cache.Set(key, initialValue, options);

            await Task.Delay(TimeSpan.FromSeconds(6));

            // Any activity on the cache (Get, Set, Remove) can trigger a background scan for expired items.
            // There's no background thread that scans the cache for expired times
            var result = cache.Get(key);

            await Task.Delay(TimeSpan.FromSeconds(1));

            Assert.IsTrue(refreshCounter &gt;= 1);
            Assert.AreEqual(newValue, cache.Get(key));
        }

        [TestMethod]
        public async Task TokenExpireAndReAddFromCallbackWorks()
        {
            var cache = CreateCache();
            var initialValue = &quot;I'm a value&quot;;
            var newValue = &quot;I'm the refreshed value&quot;;
            string key = &quot;myKey&quot;;
            int refreshCounter = 0;

            int expirationSeconds = 1;
            var expirationTime = DateTime.Now.AddSeconds(expirationSeconds);
            var expirationToken = new CancellationChangeToken(
                new CancellationTokenSource(TimeSpan.FromSeconds(expirationSeconds + .01)).Token);

            var options = new MemoryCacheEntryOptions();
            options.SetAbsoluteExpiration(expirationTime);
            options.AddExpirationToken(expirationToken);
            options.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration()
            {
                EvictionCallback = (subkey, subValue, reason, state) =&gt;
                {
                    if (reason == EvictionReason.TokenExpired)
                    {
                        cache.Set(key, newValue);
                        refreshCounter++;
                    }
                }
            });

            cache.Set(key, initialValue, options);

            await Task.Delay(TimeSpan.FromSeconds(6));

            Assert.IsTrue(refreshCounter &gt;= 1);
            Assert.AreEqual(newValue, cache.Get(key));
        }
    }
}
</code></pre>
<p>So that&rsquo;s basically it! Now we have our auto refreshing cache! There&rsquo;s a lot that we can improve. You have to be careful who has access to the keys for your specific object and a million other considerations. Caching is a steep hill to climb, but I hope you found this blog post informative in some capacity!</p>
<p>I&rsquo;ve used both implementations for some heavy objects that don&rsquo;t change often in production environments and they&rsquo;ve been doing their job pretty well so far!</p>

</article>
</div>


                
                    
                
            </div>
<footer>
    <article>Copyright © 2017-2022 by Pavel Danov</article>
</footer>

</main>
    </body>
</html>
